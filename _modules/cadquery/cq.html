

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>cadquery.cq &mdash; CadQuery Documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="CadQuery Documentation" href="../../index.html"/>
        <link rel="up" title="Module code" href="../index.html"/> 

  
  <script src="../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../index.html" class="icon icon-home"> CadQuery
          

          
            
            <img src="../../_static/cadquery_logo_dark.svg" class="logo" />
          
          </a>

          
            
            
              <div class="version">
                1.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../intro.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installing CadQuery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart.html">CadQuery QuickStart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../designprinciples.html">CadQuery Design Principles</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../primer.html">CadQuery Concepts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../fileformat.html">CadQuery Scripts and Object Output</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">CadQuery Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apireference.html">CadQuery API Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../selectors.html">String Selectors Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../selectors.html#combining-selectors">Combining Selectors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../classreference.html">CadQuery Class Summary</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cqgi.html">The CadQuery Gateway Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../extending.html">Extending CadQuery</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../roadmap.html">RoadMap:  Planned Features</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../index.html">CadQuery</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../index.html">Module code</a> &raquo;</li>
      
    <li>cadquery.cq</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for cadquery.cq</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Copyright (C) 2011-2015  Parametric Products Intellectual Holdings, LLC</span>

<span class="sd">    This file is part of CadQuery.</span>

<span class="sd">    CadQuery is free software; you can redistribute it and/or</span>
<span class="sd">    modify it under the terms of the GNU Lesser General Public</span>
<span class="sd">    License as published by the Free Software Foundation; either</span>
<span class="sd">    version 2.1 of the License, or (at your option) any later version.</span>

<span class="sd">    CadQuery is distributed in the hope that it will be useful,</span>
<span class="sd">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="sd">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="sd">    Lesser General Public License for more details.</span>

<span class="sd">    You should have received a copy of the GNU Lesser General Public</span>
<span class="sd">    License along with this library; If not, see &lt;http://www.gnu.org/licenses/&gt;</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">cadquery</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span> <span class="nn">cadquery</span> <span class="kn">import</span> <span class="n">selectors</span>
<span class="kn">from</span> <span class="nn">cadquery</span> <span class="kn">import</span> <span class="n">exporters</span>

<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span><span class="p">,</span> <span class="n">deepcopy</span>


<span class="k">class</span> <span class="nc">CQContext</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A shared context for modeling.</span>

<span class="sd">        All objects in the same CQ chain share a reference to this same object instance</span>
<span class="sd">        which allows for shared state when needed,</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pendingWires</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># a list of wires that have been created and need to be extruded</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pendingEdges</span> <span class="o">=</span> <span class="p">[]</span>   <span class="c1"># a list of created pending edges that need to be joined into wires</span>
        <span class="c1"># a reference to the first point for a set of edges.</span>
        <span class="c1"># Used to determine how to behave when close() is called</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">firstPoint</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tolerance</span> <span class="o">=</span> <span class="mf">0.0001</span>  <span class="c1"># user specified tolerance</span>


<div class="viewcode-block" id="CQ"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ">[docs]</a><span class="k">class</span> <span class="nc">CQ</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Provides enhanced functionality for a wrapped CAD primitive.</span>

<span class="sd">    Examples include feature selection, feature creation, 2d drawing</span>
<span class="sd">    using work planes, and 3d operations like fillets, shells, and splitting</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Construct a new CadQuery (CQ) object that wraps a CAD primitive.</span>

<span class="sd">        :param obj: Object to Wrap.</span>
<span class="sd">        :type obj: A CAD Primitive ( wire,vertex,face,solid,edge )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objects</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">CQContext</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">obj</span><span class="p">:</span>  <span class="c1"># guarded because sometimes None for internal use</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

<div class="viewcode-block" id="CQ.newObject"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.newObject">[docs]</a>    <span class="k">def</span> <span class="nf">newObject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objlist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a new CQ object.</span>

<span class="sd">        :param objlist: The stack of objects to use</span>
<span class="sd">        :type objlist: a list of CAD primitives ( wire,face,edge,solid,vertex,etc )</span>

<span class="sd">        The parent of the new object will be set to the current object,</span>
<span class="sd">        to preserve the chain correctly.</span>

<span class="sd">        Custom plugins and subclasses should use this method to create new CQ objects</span>
<span class="sd">        correctly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="bp">None</span><span class="p">)</span>  <span class="c1"># create a completely blank one</span>
        <span class="n">r</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">r</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span>  <span class="c1"># context solid remains the same</span>
        <span class="n">r</span><span class="o">.</span><span class="n">objects</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">objlist</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span></div>

    <span class="k">def</span> <span class="nf">_collectProperty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">propName</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Collects all of the values for propName,</span>
<span class="sd">        for all items on the stack.</span>
<span class="sd">        FreeCAD objects do not implement id correctly,</span>
<span class="sd">        so hashCode is used to ensure we don&#39;t add the same</span>
<span class="sd">        object multiple times.</span>

<span class="sd">        One weird use case is that the stack could have a solid reference object</span>
<span class="sd">        on it.  This is meant to be a reference to the most recently modified version</span>
<span class="sd">        of the context solid, whatever it is.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">all</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>

            <span class="c1"># tricky-- if an object is a compound of solids,</span>
            <span class="c1"># do not return all of the solids underneath-- typically</span>
            <span class="c1"># then we&#39;ll keep joining to ourself</span>
            <span class="k">if</span> <span class="n">propName</span> <span class="o">==</span> <span class="s1">&#39;Solids&#39;</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">Solid</span><span class="p">)</span> <span class="ow">and</span> <span class="n">o</span><span class="o">.</span><span class="n">ShapeType</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;Compound&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s1">&#39;Compounds&#39;</span><span class="p">)():</span>
                    <span class="nb">all</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">hashCode</span><span class="p">()]</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">propName</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">propName</span><span class="p">)():</span>
                        <span class="nb">all</span><span class="p">[</span><span class="n">i</span><span class="o">.</span><span class="n">hashCode</span><span class="p">()]</span> <span class="o">=</span> <span class="n">i</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">all</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>

<div class="viewcode-block" id="CQ.split"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.split">[docs]</a>    <span class="k">def</span> <span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keepTop</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">keepBottom</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Splits a solid on the stack into two parts, optionally keeping the separate parts.</span>

<span class="sd">            :param boolean keepTop: True to keep the top, False or None to discard it</span>
<span class="sd">            :param boolean keepBottom: True to keep the bottom, False or None to discard it</span>
<span class="sd">            :raises: ValueError if keepTop and keepBottom are both false.</span>
<span class="sd">            :raises: ValueError if there is not a solid in the current stack or the parent chain</span>
<span class="sd">            :returns: CQ object with the desired objects on the stack.</span>

<span class="sd">            The most common operation splits a solid and keeps one half. This sample creates</span>
<span class="sd">            split bushing::</span>

<span class="sd">                #drill a hole in the side</span>
<span class="sd">                c = Workplane().box(1,1,1).faces(&quot;&gt;Z&quot;).workplane().circle(0.25).cutThruAll()F</span>
<span class="sd">                #now cut it in half sideways</span>
<span class="sd">                c.faces(&quot;&gt;Y&quot;).workplane(-0.5).split(keepTop=True)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">solid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findSolid</span><span class="p">()</span>

        <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">keepTop</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">keepBottom</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You have to keep at least one half&quot;</span><span class="p">)</span>

        <span class="n">maxDim</span> <span class="o">=</span> <span class="n">solid</span><span class="o">.</span><span class="n">BoundingBox</span><span class="p">()</span><span class="o">.</span><span class="n">DiagonalLength</span> <span class="o">*</span> <span class="mf">10.0</span>
        <span class="n">topCutBox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="p">(</span><span class="n">maxDim</span><span class="p">,</span> <span class="n">maxDim</span><span class="p">)</span><span class="o">.</span><span class="n">_extrude</span><span class="p">(</span><span class="n">maxDim</span><span class="p">)</span>
        <span class="n">bottomCutBox</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">rect</span><span class="p">(</span><span class="n">maxDim</span><span class="p">,</span> <span class="n">maxDim</span><span class="p">)</span><span class="o">.</span><span class="n">_extrude</span><span class="p">(</span><span class="o">-</span><span class="n">maxDim</span><span class="p">)</span>

        <span class="n">top</span> <span class="o">=</span> <span class="n">solid</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">bottomCutBox</span><span class="p">)</span>
        <span class="n">bottom</span> <span class="o">=</span> <span class="n">solid</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">topCutBox</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">keepTop</span> <span class="ow">and</span> <span class="n">keepBottom</span><span class="p">:</span>
            <span class="c1"># Put both on the stack, leave original unchanged.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">top</span><span class="p">,</span> <span class="n">bottom</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Put the one we are keeping on the stack, and also update the</span>
            <span class="c1"># context solidto the one we kept.</span>
            <span class="k">if</span> <span class="n">keepTop</span><span class="p">:</span>
                <span class="n">solid</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">top</span><span class="o">.</span><span class="n">wrapped</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">top</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">solid</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">bottom</span><span class="o">.</span><span class="n">wrapped</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">bottom</span><span class="p">])</span></div>

<div class="viewcode-block" id="CQ.combineSolids"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.combineSolids">[docs]</a>    <span class="k">def</span> <span class="nf">combineSolids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">otherCQToCombine</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        !!!DEPRECATED!!! use union()</span>
<span class="sd">        Combines all solids on the current stack, and any context object, together</span>
<span class="sd">        into a single object.</span>

<span class="sd">        After the operation, the returned solid is also the context solid.</span>

<span class="sd">        :param otherCQToCombine: another CadQuery to combine.</span>
<span class="sd">        :return: a cQ object with the resulting combined solid on the stack.</span>

<span class="sd">        Most of the time, both objects will contain a single solid, which is</span>
<span class="sd">        combined and returned on the stack of the new object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#loop through current stack objects, and combine them</span>
        <span class="c1">#TODO: combine other types of objects as well, like edges and wires</span>
        <span class="n">toCombine</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">solids</span><span class="p">()</span><span class="o">.</span><span class="n">vals</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">otherCQToCombine</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="n">otherCQToCombine</span><span class="o">.</span><span class="n">solids</span><span class="p">()</span><span class="o">.</span><span class="n">vals</span><span class="p">():</span>
                <span class="n">toCombine</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">toCombine</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot Combine: at least one solid required!&quot;</span><span class="p">)</span>

        <span class="c1">#get context solid and we don&#39;t want to find our own objects</span>
        <span class="n">ctxSolid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findSolid</span><span class="p">(</span><span class="n">searchStack</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">searchParents</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ctxSolid</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">ctxSolid</span> <span class="o">=</span> <span class="n">toCombine</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1">#now combine them all. make sure to save a reference to the ctxSolid pointer!</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">ctxSolid</span>
        <span class="k">for</span> <span class="n">tc</span> <span class="ow">in</span> <span class="n">toCombine</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">fuse</span><span class="p">(</span><span class="n">tc</span><span class="p">)</span>

        <span class="n">ctxSolid</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">wrapped</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">s</span><span class="p">])</span></div>

<div class="viewcode-block" id="CQ.all"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.all">[docs]</a>    <span class="k">def</span> <span class="nf">all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of all CQ objects on the stack.</span>

<span class="sd">        useful when you need to operate on the elements</span>
<span class="sd">        individually.</span>

<span class="sd">        Contrast with vals, which returns the underlying</span>
<span class="sd">        objects for all of the items on the stack</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">o</span><span class="p">])</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">]</span></div>

<div class="viewcode-block" id="CQ.size"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.size">[docs]</a>    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Return the number of objects currently on the stack</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">)</span></div>

<div class="viewcode-block" id="CQ.vals"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.vals">[docs]</a>    <span class="k">def</span> <span class="nf">vals</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        get the values in the current list</span>

<span class="sd">        :rtype: list of FreeCAD objects</span>
<span class="sd">        :returns: the values of the objects on the stack.</span>

<span class="sd">        Contrast with :py:meth:`all`, which returns CQ objects for all of the items on the stack</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span></div>

<div class="viewcode-block" id="CQ.add"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds an object or a list of objects to the stack</span>

<span class="sd">        :param obj: an object to add</span>
<span class="sd">        :type obj: a CQ object, CAD primitive, or list of CAD primitives</span>
<span class="sd">        :return: a CQ object with the requested operation performed</span>

<span class="sd">        If an CQ object, the values of that object&#39;s stack are added. If a list of cad primitives,</span>
<span class="sd">        they are all added. If a single CAD primitive it is added</span>

<span class="sd">        Used in rare cases when you need to combine the results of several CQ results</span>
<span class="sd">        into a single CQ object. Shelling is one common example</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">CQ</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">objects</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="CQ.val"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.val">[docs]</a>    <span class="k">def</span> <span class="nf">val</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the first value on the stack</span>

<span class="sd">        :return: the first value on the stack.</span>
<span class="sd">        :rtype: A FreeCAD object or a SolidReference</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="CQ.toFreecad"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.toFreecad">[docs]</a>    <span class="k">def</span> <span class="nf">toFreecad</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Directly returns the wrapped FreeCAD object to cut down on the amount of boiler plate code</span>
<span class="sd">        needed when rendering a model in FreeCAD&#39;s 3D view.</span>
<span class="sd">        :return: The wrapped FreeCAD object</span>
<span class="sd">        :rtype A FreeCAD object or a SolidReference</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">wrapped</span></div>

<div class="viewcode-block" id="CQ.workplane"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.workplane">[docs]</a>    <span class="k">def</span> <span class="nf">workplane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">centerOption</span><span class="o">=</span><span class="s1">&#39;CenterOfMass&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new 2-D workplane, located relative to the first face on the stack.</span>

<span class="sd">        :param offset:  offset for the work plane in the Z direction. Default</span>
<span class="sd">        :param invert:  invert the Z direction from that of the face.</span>
<span class="sd">        :type offset: float or None=0.0</span>
<span class="sd">        :type invert: boolean or None=False</span>
<span class="sd">        :rtype: Workplane object ( which is a subclass of CQ )</span>

<span class="sd">        The first element on the stack must be a face, a set of</span>
<span class="sd">        co-planar faces or a vertex.  If a vertex, then the parent</span>
<span class="sd">        item on the chain immediately before the vertex must be a</span>
<span class="sd">        face.</span>

<span class="sd">        The result will be a 2-d working plane</span>
<span class="sd">        with a new coordinate system set up as follows:</span>

<span class="sd">           * The origin will be located in the *center* of the</span>
<span class="sd">             face/faces, if a face/faces was selected. If a vertex was</span>
<span class="sd">             selected, the origin will be at the vertex, and located</span>
<span class="sd">             on the face.</span>
<span class="sd">           * The Z direction will be normal to the plane of the face,computed</span>
<span class="sd">             at the center point.</span>
<span class="sd">           * The X direction will be parallel to the x-y plane. If the workplane is  parallel to</span>
<span class="sd">             the global x-y plane, the x direction of the workplane will co-incide with the</span>
<span class="sd">             global x direction.</span>

<span class="sd">        Most commonly, the selected face will be planar, and the workplane lies in the same plane</span>
<span class="sd">        of the face ( IE, offset=0).  Occasionally, it is useful to define a face offset from</span>
<span class="sd">        an existing surface, and even more rarely to define a workplane based on a face that is</span>
<span class="sd">        not planar.</span>

<span class="sd">        To create a workplane without first having a face, use the Workplane() method.</span>

<span class="sd">        Future Enhancements:</span>
<span class="sd">          * Allow creating workplane from planar wires</span>
<span class="sd">          * Allow creating workplane based on an arbitrary point on a face, not just the center.</span>
<span class="sd">            For now you can work around by creating a workplane and then offsetting the center</span>
<span class="sd">            afterwards.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_isCoPlanar</span><span class="p">(</span><span class="n">f0</span><span class="p">,</span> <span class="n">f1</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Test if two faces are on the same plane.&quot;&quot;&quot;</span>
            <span class="n">p0</span> <span class="o">=</span> <span class="n">f0</span><span class="o">.</span><span class="n">Center</span><span class="p">()</span>
            <span class="n">p1</span> <span class="o">=</span> <span class="n">f1</span><span class="o">.</span><span class="n">Center</span><span class="p">()</span>
            <span class="n">n0</span> <span class="o">=</span> <span class="n">f0</span><span class="o">.</span><span class="n">normalAt</span><span class="p">()</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="n">f1</span><span class="o">.</span><span class="n">normalAt</span><span class="p">()</span>

            <span class="c1"># test normals (direction of planes)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">n0</span><span class="o">.</span><span class="n">x</span><span class="o">-</span><span class="n">n1</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">tolerance</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">n0</span><span class="o">.</span><span class="n">y</span><span class="o">-</span><span class="n">n1</span><span class="o">.</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">tolerance</span><span class="p">)</span> <span class="ow">or</span>
                    <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">n0</span><span class="o">.</span><span class="n">z</span><span class="o">-</span><span class="n">n1</span><span class="o">.</span><span class="n">z</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">tolerance</span><span class="p">)):</span>
                <span class="k">return</span> <span class="bp">False</span>

            <span class="c1"># test if p1 is on the plane of f0 (offset of planes)</span>
            <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">n0</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">p0</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">p1</span><span class="p">))</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">tolerance</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_computeXdir</span><span class="p">(</span><span class="n">normal</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Figures out the X direction based on the given normal.</span>
<span class="sd">            :param :normal The direction that&#39;s normal to the plane.</span>
<span class="sd">            :type :normal A Vector</span>
<span class="sd">            :return A vector representing the X direction.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">xd</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">xd</span><span class="o">.</span><span class="n">Length</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">tolerance</span><span class="p">:</span>
                <span class="c1">#this face is parallel with the x-y plane, so choose x to be in global coordinates</span>
                <span class="n">xd</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">xd</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># are all objects &#39;PLANE&#39;?</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">geomType</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;PLANE&#39;</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;If multiple objects selected, they all must be planar faces.&quot;</span><span class="p">)</span>

            <span class="c1"># are all faces co-planar with each other?</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">(</span><span class="n">_isCoPlanar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Selected faces must be co-planar.&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">centerOption</span> <span class="o">==</span> <span class="s1">&#39;CenterOfMass&#39;</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="n">Shape</span><span class="o">.</span><span class="n">CombinedCenter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">centerOption</span> <span class="o">==</span> <span class="s1">&#39;CenterOfBoundBox&#39;</span><span class="p">:</span>
                <span class="n">center</span> <span class="o">=</span> <span class="n">Shape</span><span class="o">.</span><span class="n">CombinedCenterOfBoundBox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">)</span>

            <span class="n">normal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">normalAt</span><span class="p">()</span>
            <span class="n">xDir</span> <span class="o">=</span> <span class="n">_computeXdir</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Face</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">centerOption</span> <span class="o">==</span> <span class="s1">&#39;CenterOfMass&#39;</span><span class="p">:</span>
                        <span class="n">center</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">Center</span><span class="p">()</span>
                <span class="k">elif</span> <span class="n">centerOption</span> <span class="o">==</span> <span class="s1">&#39;CenterOfBoundBox&#39;</span><span class="p">:</span>
                        <span class="n">center</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">CenterOfBoundBox</span><span class="p">()</span>
                <span class="n">normal</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">normalAt</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
                <span class="n">xDir</span> <span class="o">=</span> <span class="n">_computeXdir</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s1">&#39;Center&#39;</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">centerOption</span> <span class="o">==</span> <span class="s1">&#39;CenterOfMass&#39;</span><span class="p">:</span>
                        <span class="n">center</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">Center</span><span class="p">()</span>
                    <span class="k">elif</span> <span class="n">centerOption</span> <span class="o">==</span> <span class="s1">&#39;CenterOfBoundBox&#39;</span><span class="p">:</span>
                        <span class="n">center</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">CenterOfBoundBox</span><span class="p">()</span>
                    <span class="n">normal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">zDir</span>
                    <span class="n">xDir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">xDir</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Needs a face or a vertex or point on a work plane&quot;</span><span class="p">)</span>

        <span class="c1">#invert if requested</span>
        <span class="k">if</span> <span class="n">invert</span><span class="p">:</span>
            <span class="n">normal</span> <span class="o">=</span> <span class="n">normal</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>

        <span class="c1">#offset origin if desired</span>
        <span class="n">offsetVector</span> <span class="o">=</span> <span class="n">normal</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">offsetCenter</span> <span class="o">=</span> <span class="n">center</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">offsetVector</span><span class="p">)</span>

        <span class="c1">#make the new workplane</span>
        <span class="n">plane</span> <span class="o">=</span> <span class="n">Plane</span><span class="p">(</span><span class="n">offsetCenter</span><span class="p">,</span> <span class="n">xDir</span><span class="p">,</span> <span class="n">normal</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">Workplane</span><span class="p">(</span><span class="n">plane</span><span class="p">)</span>
        <span class="n">s</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">s</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span>

        <span class="c1">#a new workplane has the center of the workplane on the stack</span>
        <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="CQ.first"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.first">[docs]</a>    <span class="k">def</span> <span class="nf">first</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the first item on the stack</span>
<span class="sd">        :returns: the first item on the stack.</span>
<span class="sd">        :rtype: a CQ object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="CQ.item"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.item">[docs]</a>    <span class="k">def</span> <span class="nf">item</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">i</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Return the ith item on the stack.</span>
<span class="sd">        :rtype: a CQ object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span></div>

<div class="viewcode-block" id="CQ.last"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.last">[docs]</a>    <span class="k">def</span> <span class="nf">last</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the last item on the stack.</span>
<span class="sd">        :rtype: a CQ object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span></div>

<div class="viewcode-block" id="CQ.end"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.end">[docs]</a>    <span class="k">def</span> <span class="nf">end</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the parent of this CQ element</span>
<span class="sd">        :rtype: a CQ object</span>
<span class="sd">        :raises: ValueError if there are no more parents in the chain.</span>

<span class="sd">        For example::</span>

<span class="sd">            CQ(obj).faces(&quot;+Z&quot;).vertices().end()</span>

<span class="sd">        will return the same as::</span>

<span class="sd">            CQ(obj).faces(&quot;+Z&quot;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot End the chain-- no parents!&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="CQ.findSolid"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.findSolid">[docs]</a>    <span class="k">def</span> <span class="nf">findSolid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">searchStack</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">searchParents</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the first solid object in the chain, searching from the current node</span>
<span class="sd">        backwards through parents until one is found.</span>

<span class="sd">        :param searchStack: should objects on the stack be searched first.</span>
<span class="sd">        :param searchParents: should parents be searched?</span>
<span class="sd">        :raises: ValueError if no solid is found in the current object or its parents,</span>
<span class="sd">            and errorOnEmpty is True</span>

<span class="sd">        This function is very important for chains that are modifying a single parent object,</span>
<span class="sd">        most often a solid.</span>

<span class="sd">        Most of the time, a chain defines or selects a solid, and then modifies it using workplanes</span>
<span class="sd">        or other operations.</span>

<span class="sd">        Plugin Developers should make use of this method to find the solid that should be modified,</span>
<span class="sd">        if the plugin implements a unary operation, or if the operation will automatically merge its</span>
<span class="sd">        results with an object already on the stack.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#notfound = ValueError(&quot;Cannot find a Valid Solid to Operate on!&quot;)</span>

        <span class="k">if</span> <span class="n">searchStack</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Solid</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">s</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Compound</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">Solids</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">searchParents</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">findSolid</span><span class="p">(</span><span class="n">searchStack</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">searchParents</span><span class="o">=</span><span class="n">searchParents</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">None</span></div>

    <span class="k">def</span> <span class="nf">_selectObjects</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objType</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Filters objects of the selected type with the specified selector,and returns results</span>

<span class="sd">            :param objType: the type of object we are searching for</span>
<span class="sd">            :type objType: string: (Vertex|Edge|Wire|Solid|Shell|Compound|CompSolid)</span>
<span class="sd">            :return: a CQ object with the selected objects on the stack.</span>

<span class="sd">            **Implementation Note**: This is the base implementation of the vertices,edges,faces,</span>
<span class="sd">            solids,shells, and other similar selector methods.  It is a useful extension point for</span>
<span class="sd">            plugin developers to make other selector methods.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># A single list of all faces from all objects on the stack</span>
        <span class="n">toReturn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_collectProperty</span><span class="p">(</span><span class="n">objType</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">selector</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># if isinstance(selector, str) or isinstance(selector, str):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">selectorObj</span> <span class="o">=</span> <span class="n">selectors</span><span class="o">.</span><span class="n">StringSyntaxSelector</span><span class="p">(</span><span class="n">selector</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">selectorObj</span> <span class="o">=</span> <span class="n">selector</span>
            <span class="n">toReturn</span> <span class="o">=</span> <span class="n">selectorObj</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">toReturn</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">(</span><span class="n">toReturn</span><span class="p">)</span>

<div class="viewcode-block" id="CQ.vertices"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.vertices">[docs]</a>    <span class="k">def</span> <span class="nf">vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select the vertices of objects on the stack, optionally filtering the selection. If there</span>
<span class="sd">        are multiple objects on the stack, the vertices of all objects are collected and a list of</span>
<span class="sd">        all the distinct vertices is returned.</span>

<span class="sd">        :param selector:</span>
<span class="sd">        :type selector:  None, a Selector object, or a string selector expression.</span>
<span class="sd">        :return: a CQ object who&#39;s stack contains  the *distinct* vertices of *all* objects on the</span>
<span class="sd">           current stack, after being filtered by the selector, if provided</span>

<span class="sd">        If there are no vertices for any objects on the current stack, an empty CQ object</span>
<span class="sd">        is returned</span>

<span class="sd">        The typical use is to select the vertices of a single object on the stack. For example::</span>

<span class="sd">           Workplane().box(1,1,1).faces(&quot;+Z&quot;).vertices().size()</span>

<span class="sd">        returns 4, because the topmost face of cube will contain four vertices. While this::</span>

<span class="sd">           Workplane().box(1,1,1).faces().vertices().size()</span>

<span class="sd">        returns 8, because a cube has a total of 8 vertices</span>

<span class="sd">        **Note** Circles are peculiar, they have a single vertex at the center!</span>

<span class="sd">        :py:class:`StringSyntaxSelector`</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selectObjects</span><span class="p">(</span><span class="s1">&#39;Vertices&#39;</span><span class="p">,</span> <span class="n">selector</span><span class="p">)</span></div>

<div class="viewcode-block" id="CQ.faces"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.faces">[docs]</a>    <span class="k">def</span> <span class="nf">faces</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select the faces of objects on the stack, optionally filtering the selection. If there are</span>
<span class="sd">        multiple objects on the stack, the faces of all objects are collected and a list of all the</span>
<span class="sd">        distinct faces is returned.</span>

<span class="sd">        :param selector: A selector</span>
<span class="sd">        :type selector:  None, a Selector object, or a string selector expression.</span>
<span class="sd">        :return: a CQ object who&#39;s stack contains all of the *distinct* faces of *all* objects on</span>
<span class="sd">            the current stack, filtered by the provided selector.</span>

<span class="sd">        If there are no vertices for any objects on the current stack, an empty CQ object</span>
<span class="sd">        is returned.</span>

<span class="sd">        The typical use is to select the faces of a single object on the stack. For example::</span>

<span class="sd">           CQ(aCube).faces(&quot;+Z&quot;).size()</span>

<span class="sd">        returns 1, because a cube has one face with a normal in the +Z direction. Similarly::</span>

<span class="sd">           CQ(aCube).faces().size()</span>

<span class="sd">        returns 6, because a cube has a total of 6 faces, And::</span>

<span class="sd">            CQ(aCube).faces(&quot;|Z&quot;).size()</span>

<span class="sd">        returns 2, because a cube has 2 faces having normals parallel to the z direction</span>

<span class="sd">        See more about selectors HERE</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selectObjects</span><span class="p">(</span><span class="s1">&#39;Faces&#39;</span><span class="p">,</span> <span class="n">selector</span><span class="p">)</span></div>

<div class="viewcode-block" id="CQ.edges"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.edges">[docs]</a>    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select the edges of objects on the stack, optionally filtering the selection. If there are</span>
<span class="sd">        multiple objects on the stack, the edges of all objects are collected and a list of all the</span>
<span class="sd">        distinct edges is returned.</span>

<span class="sd">        :param selector: A selector</span>
<span class="sd">        :type selector:  None, a Selector object, or a string selector expression.</span>
<span class="sd">        :return: a CQ object who&#39;s stack contains all of the *distinct* edges of *all* objects on</span>
<span class="sd">            the current stack, filtered by the provided selector.</span>

<span class="sd">        If there are no edges for any objects on the current stack, an empty CQ object is returned</span>

<span class="sd">        The typical use is to select the edges of a single object on the stack. For example::</span>

<span class="sd">           CQ(aCube).faces(&quot;+Z&quot;).edges().size()</span>

<span class="sd">        returns 4, because a cube has one face with a normal in the +Z direction. Similarly::</span>

<span class="sd">           CQ(aCube).edges().size()</span>

<span class="sd">        returns 12, because a cube has a total of 12 edges, And::</span>

<span class="sd">            CQ(aCube).edges(&quot;|Z&quot;).size()</span>

<span class="sd">        returns 4, because a cube has 4 edges parallel to the z direction</span>

<span class="sd">        See more about selectors HERE</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selectObjects</span><span class="p">(</span><span class="s1">&#39;Edges&#39;</span><span class="p">,</span> <span class="n">selector</span><span class="p">)</span></div>

<div class="viewcode-block" id="CQ.wires"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.wires">[docs]</a>    <span class="k">def</span> <span class="nf">wires</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select the wires of objects on the stack, optionally filtering the selection. If there are</span>
<span class="sd">        multiple objects on the stack, the wires of all objects are collected and a list of all the</span>
<span class="sd">        distinct wires is returned.</span>

<span class="sd">        :param selector: A selector</span>
<span class="sd">        :type selector:  None, a Selector object, or a string selector expression.</span>
<span class="sd">        :return: a CQ object who&#39;s stack contains all of the *distinct* wires of *all* objects on</span>
<span class="sd">            the current stack, filtered by the provided selector.</span>

<span class="sd">        If there are no wires for any objects on the current stack, an empty CQ object is returned</span>

<span class="sd">        The typical use is to select the wires of a single object on the stack. For example::</span>

<span class="sd">           CQ(aCube).faces(&quot;+Z&quot;).wires().size()</span>

<span class="sd">        returns 1, because a face typically only has one outer wire</span>

<span class="sd">        See more about selectors HERE</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selectObjects</span><span class="p">(</span><span class="s1">&#39;Wires&#39;</span><span class="p">,</span> <span class="n">selector</span><span class="p">)</span></div>

<div class="viewcode-block" id="CQ.solids"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.solids">[docs]</a>    <span class="k">def</span> <span class="nf">solids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select the solids of objects on the stack, optionally filtering the selection. If there are</span>
<span class="sd">        multiple objects on the stack, the solids of all objects are collected and a list of all the</span>
<span class="sd">        distinct solids is returned.</span>

<span class="sd">        :param selector: A selector</span>
<span class="sd">        :type selector:  None, a Selector object, or a string selector expression.</span>
<span class="sd">        :return: a CQ object who&#39;s stack contains all of the *distinct* solids of *all* objects on</span>
<span class="sd">            the current stack, filtered by the provided selector.</span>

<span class="sd">        If there are no solids for any objects on the current stack, an empty CQ object is returned</span>

<span class="sd">        The typical use is to select the  a single object on the stack. For example::</span>

<span class="sd">           CQ(aCube).solids().size()</span>

<span class="sd">        returns 1, because a cube consists of one solid.</span>

<span class="sd">        It is possible for single CQ object ( or even a single CAD primitive ) to contain</span>
<span class="sd">        multiple solids.</span>

<span class="sd">        See more about selectors HERE</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selectObjects</span><span class="p">(</span><span class="s1">&#39;Solids&#39;</span><span class="p">,</span> <span class="n">selector</span><span class="p">)</span></div>

<div class="viewcode-block" id="CQ.shells"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.shells">[docs]</a>    <span class="k">def</span> <span class="nf">shells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select the shells of objects on the stack, optionally filtering the selection. If there are</span>
<span class="sd">        multiple objects on the stack, the shells of all objects are collected and a list of all the</span>
<span class="sd">        distinct shells is returned.</span>

<span class="sd">        :param selector: A selector</span>
<span class="sd">        :type selector:  None, a Selector object, or a string selector expression.</span>
<span class="sd">        :return: a CQ object who&#39;s stack contains all of the *distinct* solids of *all* objects on</span>
<span class="sd">            the current stack, filtered by the provided selector.</span>

<span class="sd">        If there are no shells for any objects on the current stack, an empty CQ object is returned</span>

<span class="sd">        Most solids will have a single shell, which represents the outer surface. A shell will</span>
<span class="sd">        typically be composed of multiple faces.</span>

<span class="sd">        See more about selectors HERE</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selectObjects</span><span class="p">(</span><span class="s1">&#39;Shells&#39;</span><span class="p">,</span> <span class="n">selector</span><span class="p">)</span></div>

<div class="viewcode-block" id="CQ.compounds"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.compounds">[docs]</a>    <span class="k">def</span> <span class="nf">compounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">selector</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Select compounds on the stack, optionally filtering the selection. If there are multiple</span>
<span class="sd">        objects on the stack, they are collected and a list of all the distinct compounds</span>
<span class="sd">        is returned.</span>

<span class="sd">        :param selector: A selector</span>
<span class="sd">        :type selector:  None, a Selector object, or a string selector expression.</span>
<span class="sd">        :return: a CQ object who&#39;s stack contains all of the *distinct* solids of *all* objects on</span>
<span class="sd">            the current stack, filtered by the provided selector.</span>

<span class="sd">        A compound contains multiple CAD primitives that resulted from a single operation, such as</span>
<span class="sd">        a union, cut, split, or fillet.  Compounds can contain multiple edges, wires, or solids.</span>

<span class="sd">        See more about selectors HERE</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_selectObjects</span><span class="p">(</span><span class="s1">&#39;Compounds&#39;</span><span class="p">,</span> <span class="n">selector</span><span class="p">)</span></div>

<div class="viewcode-block" id="CQ.toSvg"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.toSvg">[docs]</a>    <span class="k">def</span> <span class="nf">toSvg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">opts</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">view_vector</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">1.75</span><span class="p">,</span><span class="mf">1.1</span><span class="p">,</span><span class="mi">5</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns svg text that represents the first item on the stack.</span>

<span class="sd">        for testing purposes.</span>

<span class="sd">        :param opts: svg formatting options</span>
<span class="sd">        :type opts: dictionary, width and height</span>

<span class="sd">        :param view_vector: camera&#39;s view direction vector</span>
<span class="sd">        :type view_vector: tuple, (x, y, z)</span>
<span class="sd">        :return: a string that contains SVG that represents this item.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">exporters</span><span class="o">.</span><span class="n">getSVG</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">()</span><span class="o">.</span><span class="n">wrapped</span><span class="p">,</span> <span class="n">opts</span><span class="o">=</span><span class="n">opts</span><span class="p">,</span> <span class="n">view_vector</span><span class="o">=</span><span class="n">view_vector</span><span class="p">)</span></div>

<div class="viewcode-block" id="CQ.exportSvg"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.exportSvg">[docs]</a>    <span class="k">def</span> <span class="nf">exportSvg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileName</span><span class="p">,</span> <span class="n">view_vector</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="mf">1.75</span><span class="p">,</span><span class="mf">1.1</span><span class="p">,</span><span class="mi">5</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Exports the first item on the stack as an SVG file</span>

<span class="sd">        For testing purposes mainly.</span>

<span class="sd">        :param fileName: the filename to export</span>

<span class="sd">        :param view_vector: camera&#39;s view direction vector</span>
<span class="sd">        :type view_vector: tuple, (x, y, z)</span>
<span class="sd">        :type fileName: String, absolute path to the file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">exporters</span><span class="o">.</span><span class="n">exportSVG</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fileName</span><span class="p">,</span> <span class="n">view_vector</span><span class="p">)</span></div>

<div class="viewcode-block" id="CQ.rotateAboutCenter"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.rotateAboutCenter">[docs]</a>    <span class="k">def</span> <span class="nf">rotateAboutCenter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axisEndPoint</span><span class="p">,</span> <span class="n">angleDegrees</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Rotates all items on the stack by the specified angle, about the specified axis</span>

<span class="sd">        The center of rotation is a vector starting at the center of the object on the stack,</span>
<span class="sd">        and ended at the specified point.</span>

<span class="sd">        :param axisEndPoint: the second point of axis of rotation</span>
<span class="sd">        :type axisEndPoint: a three-tuple in global coordinates</span>
<span class="sd">        :param angleDegrees: the rotation angle, in degrees</span>
<span class="sd">        :type angleDegrees: float</span>
<span class="sd">        :returns: a CQ object, with all items rotated.</span>

<span class="sd">        WARNING: This version returns the same cq object instead of a new one-- the</span>
<span class="sd">        old object is not accessible.</span>

<span class="sd">        Future Enhancements:</span>
<span class="sd">            * A version of this method that returns a transformed copy, rather than modifying</span>
<span class="sd">              the originals</span>
<span class="sd">            * This method doesnt expose a very good interface, because the axis of rotation</span>
<span class="sd">              could be inconsistent between multiple objects.  This is because the beginning</span>
<span class="sd">              of the axis is variable, while the end is fixed. This is fine when operating on</span>
<span class="sd">              one object, but is not cool for multiple.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#center point is the first point in the vector</span>
        <span class="n">endVec</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">axisEndPoint</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_rot</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="n">startPt</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">Center</span><span class="p">()</span>
            <span class="n">endPt</span> <span class="o">=</span> <span class="n">startPt</span> <span class="o">+</span> <span class="n">endVec</span>
            <span class="k">return</span> <span class="n">obj</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">startPt</span><span class="p">,</span> <span class="n">endPt</span><span class="p">,</span> <span class="n">angleDegrees</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">each</span><span class="p">(</span><span class="n">_rot</span><span class="p">,</span> <span class="bp">False</span><span class="p">)</span></div>

<div class="viewcode-block" id="CQ.rotate"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axisStartPoint</span><span class="p">,</span> <span class="n">axisEndPoint</span><span class="p">,</span> <span class="n">angleDegrees</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of all of the items on the stack rotated through and angle around the axis</span>
<span class="sd">        of rotation.</span>

<span class="sd">        :param axisStartPoint: The first point of the axis of rotation</span>
<span class="sd">        :type axisStartPoint: a 3-tuple of floats</span>
<span class="sd">        :type axisEndPoint: The second point of the axis of rotation</span>
<span class="sd">        :type axisEndPoint: a 3-tuple of floats</span>
<span class="sd">        :param angleDegrees: the rotation angle, in degrees</span>
<span class="sd">        :type angleDegrees: float</span>
<span class="sd">        :returns: a CQ object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">axisStartPoint</span><span class="p">,</span> <span class="n">axisEndPoint</span><span class="p">,</span> <span class="n">angleDegrees</span><span class="p">)</span>
                               <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">])</span></div>

<div class="viewcode-block" id="CQ.mirror"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.mirror">[docs]</a>    <span class="k">def</span> <span class="nf">mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mirrorPlane</span><span class="o">=</span><span class="s2">&quot;XY&quot;</span><span class="p">,</span> <span class="n">basePointVector</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mirror a single CQ object. This operation is the same as in the FreeCAD PartWB&#39;s mirroring</span>

<span class="sd">        :param mirrorPlane: the plane to mirror about</span>
<span class="sd">        :type mirrorPlane: string, one of &quot;XY&quot;, &quot;YX&quot;, &quot;XZ&quot;, &quot;ZX&quot;, &quot;YZ&quot;, &quot;ZY&quot; the planes</span>
<span class="sd">        :param basePointVector: the base point to mirror about</span>
<span class="sd">        :type basePointVector: tuple</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="n">mirrorPlane</span><span class="p">,</span> <span class="n">basePointVector</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">newS</span><span class="o">.</span><span class="n">first</span><span class="p">()</span></div>


<div class="viewcode-block" id="CQ.translate"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vec</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a copy of all of the items on the stack moved by the specified translation vector.</span>

<span class="sd">        :param tupleDistance: distance to move, in global coordinates</span>
<span class="sd">        :type  tupleDistance: a 3-tuple of float</span>
<span class="sd">        :returns: a CQ object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">o</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span> <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">])</span></div>


<div class="viewcode-block" id="CQ.shell"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.shell">[docs]</a>    <span class="k">def</span> <span class="nf">shell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">thickness</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove the selected faces to create a shell of the specified thickness.</span>

<span class="sd">        To shell, first create a solid, and *in the same chain* select the faces you wish to remove.</span>

<span class="sd">        :param thickness: a positive float, representing the thickness of the desired shell.</span>
<span class="sd">            Negative values shell inwards, positive values shell outwards.</span>
<span class="sd">        :raises: ValueError if the current stack contains objects that are not faces of a solid</span>
<span class="sd">             further up in the chain.</span>
<span class="sd">        :returns: a CQ object with the resulting shelled solid selected.</span>

<span class="sd">        This example will create a hollowed out unit cube, where the top most face is open,</span>
<span class="sd">        and all other walls are 0.2 units thick::</span>

<span class="sd">            Workplane().box(1,1,1).faces(&quot;+Z&quot;).shell(0.2)</span>

<span class="sd">        Shelling is one of the cases where you may need to use the add method to select several</span>
<span class="sd">        faces. For example, this example creates a 3-walled corner, by removing three faces</span>
<span class="sd">        of a cube::</span>

<span class="sd">            s = Workplane().box(1,1,1)</span>
<span class="sd">            s1 = s.faces(&quot;+Z&quot;)</span>
<span class="sd">            s1.add(s.faces(&quot;+Y&quot;)).add(s.faces(&quot;+X&quot;))</span>
<span class="sd">            self.saveModel(s1.shell(0.2))</span>

<span class="sd">        This fairly yucky syntax for selecting multiple faces is planned for improvement</span>

<span class="sd">        **Note**:  When sharp edges are shelled inwards, they remain sharp corners, but **outward**</span>
<span class="sd">        shells are automatically filleted, because an outward offset from a corner generates</span>
<span class="sd">        a radius.</span>


<span class="sd">        Future Enhancements:</span>
<span class="sd">            Better selectors to make it easier to select multiple faces</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">solidRef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findSolid</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Face</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Shelling requires that faces be selected&quot;</span><span class="p">)</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">solidRef</span><span class="o">.</span><span class="n">shell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">,</span> <span class="n">thickness</span><span class="p">)</span>
        <span class="n">solidRef</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">wrapped</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">s</span><span class="p">])</span></div>

<div class="viewcode-block" id="CQ.fillet"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.fillet">[docs]</a>    <span class="k">def</span> <span class="nf">fillet</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fillets a solid on the selected edges.</span>

<span class="sd">        The edges on the stack are filleted. The solid to which the edges belong must be in the</span>
<span class="sd">        parent chain of the selected edges.</span>

<span class="sd">        :param radius: the radius of the fillet, must be &gt; zero</span>
<span class="sd">        :type radius: positive float</span>
<span class="sd">        :raises: ValueError if at least one edge is not selected</span>
<span class="sd">        :raises: ValueError if the solid containing the edge is not in the chain</span>
<span class="sd">        :returns: cq object with the resulting solid selected.</span>

<span class="sd">        This example will create a unit cube, with the top edges filleted::</span>

<span class="sd">            s = Workplane().box(1,1,1).faces(&quot;+Z&quot;).edges().fillet(0.1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># TODO: we will need much better edge selectors for this to work</span>
        <span class="c1"># TODO: ensure that edges selected actually belong to the solid in the chain, otherwise,</span>
        <span class="c1"># TODO: we segfault</span>

        <span class="n">solid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findSolid</span><span class="p">()</span>

        <span class="n">edgeList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span><span class="o">.</span><span class="n">vals</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edgeList</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Fillets requires that edges be selected&quot;</span><span class="p">)</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">solid</span><span class="o">.</span><span class="n">fillet</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">edgeList</span><span class="p">)</span>
        <span class="n">solid</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">wrapped</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">s</span><span class="p">])</span></div>

<div class="viewcode-block" id="CQ.chamfer"><a class="viewcode-back" href="../../classreference.html#cadquery.CQ.chamfer">[docs]</a>    <span class="k">def</span> <span class="nf">chamfer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">length2</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Chamfers a solid on the selected edges.</span>

<span class="sd">        The edges on the stack are chamfered. The solid to which the</span>
<span class="sd">        edges belong must be in the parent chain of the selected</span>
<span class="sd">        edges.</span>

<span class="sd">        Optional parameter `length2` can be supplied with a different</span>
<span class="sd">        value than `length` for a chamfer that is shorter on one side</span>
<span class="sd">        longer on the other side.</span>

<span class="sd">        :param length: the length of the fillet, must be greater than zero</span>
<span class="sd">        :param length2: optional parameter for asymmetrical chamfer</span>
<span class="sd">        :type length: positive float</span>
<span class="sd">        :type length2: positive float</span>
<span class="sd">        :raises: ValueError if at least one edge is not selected</span>
<span class="sd">        :raises: ValueError if the solid containing the edge is not in the chain</span>
<span class="sd">        :returns: cq object with the resulting solid selected.</span>

<span class="sd">        This example will create a unit cube, with the top edges chamfered::</span>

<span class="sd">            s = Workplane(&quot;XY&quot;).box(1,1,1).faces(&quot;+Z&quot;).chamfer(0.1)</span>

<span class="sd">        This example will create chamfers longer on the sides::</span>

<span class="sd">            s = Workplane(&quot;XY&quot;).box(1,1,1).faces(&quot;+Z&quot;).chamfer(0.2, 0.1)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">solid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findSolid</span><span class="p">()</span>

        <span class="n">edgeList</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">()</span><span class="o">.</span><span class="n">vals</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edgeList</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Chamfer requires that edges be selected&quot;</span><span class="p">)</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">solid</span><span class="o">.</span><span class="n">chamfer</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">length2</span><span class="p">,</span> <span class="n">edgeList</span><span class="p">)</span>

        <span class="n">solid</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">wrapped</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">s</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">__copy__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">(</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__deepcopy__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">memo</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">(</span><span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">,</span> <span class="n">memo</span><span class="p">))</span></div>


<div class="viewcode-block" id="Workplane"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane">[docs]</a><span class="k">class</span> <span class="nc">Workplane</span><span class="p">(</span><span class="n">CQ</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines a coordinate system in space, in which 2-d coordinates can be used.</span>

<span class="sd">    :param plane: the plane in which the workplane will be done</span>
<span class="sd">    :type plane: a Plane object, or a string in (XY|YZ|XZ|front|back|top|bottom|left|right)</span>
<span class="sd">    :param origin: the desired origin of the new workplane</span>
<span class="sd">    :type origin: a 3-tuple in global coordinates, or None to default to the origin</span>
<span class="sd">    :param obj: an object to use initially for the stack</span>
<span class="sd">    :type obj: a CAD primitive, or None to use the centerpoint of the plane as the initial</span>
<span class="sd">        stack value.</span>
<span class="sd">    :raises: ValueError if the provided plane is not a plane, a valid named workplane</span>
<span class="sd">    :return: A Workplane object, with coordinate system matching the supplied plane.</span>

<span class="sd">    The most common use is::</span>

<span class="sd">        s = Workplane(&quot;XY&quot;)</span>

<span class="sd">    After creation, the stack contains a single point, the origin of the underlying plane,</span>
<span class="sd">    and the *current point* is on the origin.</span>

<span class="sd">    .. note::</span>
<span class="sd">        You can also create workplanes on the surface of existing faces using</span>
<span class="sd">        :py:meth:`CQ.workplane`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">FOR_CONSTRUCTION</span> <span class="o">=</span> <span class="s1">&#39;ForConstruction&#39;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">inPlane</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">obj</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        make a workplane from a particular plane</span>

<span class="sd">        :param inPlane: the plane in which the workplane will be done</span>
<span class="sd">        :type inPlane: a Plane object, or a string in (XY|YZ|XZ|front|back|top|bottom|left|right)</span>
<span class="sd">        :param origin: the desired origin of the new workplane</span>
<span class="sd">        :type origin: a 3-tuple in global coordinates, or None to default to the origin</span>
<span class="sd">        :param obj: an object to use initially for the stack</span>
<span class="sd">        :type obj: a CAD primitive, or None to use the centerpoint of the plane as the initial</span>
<span class="sd">            stack value.</span>
<span class="sd">        :raises: ValueError if the provided plane is not a plane, or one of XY|YZ|XZ</span>
<span class="sd">        :return: A Workplane object, with coordinate system matching the supplied plane.</span>

<span class="sd">        The most common use is::</span>

<span class="sd">            s = Workplane(&quot;XY&quot;)</span>

<span class="sd">        After creation, the stack contains a single point, the origin of the underlying plane, and</span>
<span class="sd">        the *current point* is on the origin.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">inPlane</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;Plane&#39;</span><span class="p">:</span>
            <span class="n">tmpPlane</span> <span class="o">=</span> <span class="n">inPlane</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">tmpPlane</span> <span class="o">=</span> <span class="n">Plane</span><span class="o">.</span><span class="n">named</span><span class="p">(</span><span class="n">inPlane</span><span class="p">,</span> <span class="n">origin</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">tmpPlane</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="n">tmpPlane</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;Provided value {} is not a valid work plane&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">inPlane</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">obj</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plane</span> <span class="o">=</span> <span class="n">tmpPlane</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">firstPoint</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="c1"># Changed so that workplane has the center as the first item on the stack</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">objects</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">origin</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">CQContext</span><span class="p">()</span>

<div class="viewcode-block" id="Workplane.transformed"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.transformed">[docs]</a>    <span class="k">def</span> <span class="nf">transformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rotate</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new workplane based on the current one.</span>
<span class="sd">        The origin of the new plane is located at the existing origin+offset vector, where offset is</span>
<span class="sd">        given in coordinates local to the current plane</span>
<span class="sd">        The new plane is rotated through the angles specified by the components of the rotation</span>
<span class="sd">        vector.</span>
<span class="sd">        :param rotate: 3-tuple of angles to rotate, in degrees relative to work plane coordinates</span>
<span class="sd">        :param offset: 3-tuple to offset the new plane, in local work plane coordinates</span>
<span class="sd">        :return: a new work plane, transformed as requested</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#old api accepted a vector, so we&#39;ll check for that.</span>
        <span class="k">if</span> <span class="n">rotate</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;Vector&#39;</span><span class="p">:</span>
            <span class="n">rotate</span> <span class="o">=</span> <span class="n">rotate</span><span class="o">.</span><span class="n">toTuple</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">offset</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;Vector&#39;</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="o">.</span><span class="n">toTuple</span><span class="p">()</span>

        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">rotated</span><span class="p">(</span><span class="n">rotate</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">toWorldCoords</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">origin</span><span class="p">])</span>
        <span class="n">ns</span><span class="o">.</span><span class="n">plane</span> <span class="o">=</span> <span class="n">p</span>

        <span class="k">return</span> <span class="n">ns</span></div>

<div class="viewcode-block" id="Workplane.newObject"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.newObject">[docs]</a>    <span class="k">def</span> <span class="nf">newObject</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objlist</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a new workplane object from this one.</span>

<span class="sd">        Overrides CQ.newObject, and should be used by extensions, plugins, and</span>
<span class="sd">        subclasses to create new objects.</span>

<span class="sd">        :param objlist: new objects to put on the stack</span>
<span class="sd">        :type objlist: a list of CAD primitives</span>
<span class="sd">        :return: a new Workplane object with the current workplane as a parent.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#copy the current state to the new object</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)(</span><span class="s2">&quot;XY&quot;</span><span class="p">)</span>
        <span class="n">ns</span><span class="o">.</span><span class="n">plane</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span>
        <span class="n">ns</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">ns</span><span class="o">.</span><span class="n">objects</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">objlist</span><span class="p">)</span>
        <span class="n">ns</span><span class="o">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span>
        <span class="k">return</span> <span class="n">ns</span></div>

    <span class="k">def</span> <span class="nf">_findFromPoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">useLocalCoords</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the start point for an operation when an existing point</span>
<span class="sd">        is implied.  Examples include 2d operations such as lineTo,</span>
<span class="sd">        which allows specifying the end point, and implicitly use the</span>
<span class="sd">        end of the previous line as the starting point</span>

<span class="sd">        :return: a Vector representing the point to use, or none if</span>
<span class="sd">        such a point is not available.</span>

<span class="sd">        :param useLocalCoords: selects whether the point is returned</span>
<span class="sd">        in local coordinates or global coordinates.</span>

<span class="sd">        The algorithm is this:</span>
<span class="sd">            * If an Edge is on the stack, its end point is used.yp</span>
<span class="sd">            * if a vector is on the stack, it is used</span>

<span class="sd">        WARNING: only the last object on the stack is used.</span>

<span class="sd">        NOTE:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Edge</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">endPoint</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">Vector</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Cannot convert object type &#39;</span><span class="si">%s</span><span class="s2">&#39; to vector &quot;</span> <span class="o">%</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">useLocalCoords</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">toLocalCoords</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">p</span>

<div class="viewcode-block" id="Workplane.rarray"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.rarray">[docs]</a>    <span class="k">def</span> <span class="nf">rarray</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xSpacing</span><span class="p">,</span> <span class="n">ySpacing</span><span class="p">,</span> <span class="n">xCount</span><span class="p">,</span> <span class="n">yCount</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an array of points and pushes them onto the stack.</span>
<span class="sd">        If you want to position the array at another point, create another workplane</span>
<span class="sd">        that is shifted to the position you would like to use as a reference</span>

<span class="sd">        :param xSpacing: spacing between points in the x direction ( must be &gt; 0)</span>
<span class="sd">        :param ySpacing: spacing between points in the y direction ( must be &gt; 0)</span>
<span class="sd">        :param xCount: number of points ( &gt; 0 )</span>
<span class="sd">        :param yCount: number of points ( &gt; 0 )</span>
<span class="sd">        :param center: if true, the array will be centered at the center of the workplane. if</span>
<span class="sd">            false, the lower left corner will be at the center of the work plane</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">xSpacing</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">ySpacing</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">xCount</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">yCount</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Spacing and count must be &gt; 0 &quot;</span><span class="p">)</span>

        <span class="n">lpoints</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># coordinates relative to bottom left point</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">xCount</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">yCount</span><span class="p">):</span>
                <span class="n">lpoints</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">xSpacing</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">ySpacing</span> <span class="o">*</span> <span class="n">y</span><span class="p">))</span>

        <span class="c1">#shift points down and left relative to origin if requested</span>
        <span class="k">if</span> <span class="n">center</span><span class="p">:</span>
            <span class="n">xc</span> <span class="o">=</span> <span class="n">xSpacing</span><span class="o">*</span><span class="p">(</span><span class="n">xCount</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span>
            <span class="n">yc</span> <span class="o">=</span> <span class="n">ySpacing</span><span class="o">*</span><span class="p">(</span><span class="n">yCount</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span>
            <span class="n">cpoints</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">lpoints</span><span class="p">:</span>
                <span class="n">cpoints</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">xc</span><span class="p">,</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">yc</span><span class="p">))</span>
            <span class="n">lpoints</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">cpoints</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pushPoints</span><span class="p">(</span><span class="n">lpoints</span><span class="p">)</span></div>

<div class="viewcode-block" id="Workplane.pushPoints"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.pushPoints">[docs]</a>    <span class="k">def</span> <span class="nf">pushPoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pntList</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pushes a list of points onto the stack as vertices.</span>
<span class="sd">        The points are in the 2-d coordinate space of the workplane face</span>

<span class="sd">        :param pntList: a list of points to push onto the stack</span>
<span class="sd">        :type pntList: list of 2-tuples, in *local* coordinates</span>
<span class="sd">        :return: a new workplane with the desired points on the stack.</span>

<span class="sd">        A common use is to provide a list of points for a subsequent operation, such as creating</span>
<span class="sd">        circles or holes. This example creates a cube, and then drills three holes through it,</span>
<span class="sd">        based on three points::</span>

<span class="sd">            s = Workplane().box(1,1,1).faces(&quot;&gt;Z&quot;).workplane().\</span>
<span class="sd">                pushPoints([(-0.3,0.3),(0.3,0.3),(0,0)])</span>
<span class="sd">            body = s.circle(0.05).cutThruAll()</span>

<span class="sd">        Here the circle function operates on all three points, and is then extruded to create three</span>
<span class="sd">        holes. See :py:meth:`circle` for how it works.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vecs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">pnt</span> <span class="ow">in</span> <span class="n">pntList</span><span class="p">:</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">toWorldCoords</span><span class="p">(</span><span class="n">pnt</span><span class="p">)</span>
            <span class="n">vecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vec</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">(</span><span class="n">vecs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Workplane.center"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.center">[docs]</a>    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shift local coordinates to the specified location.</span>

<span class="sd">        The location is specified in terms of local coordinates.</span>

<span class="sd">        :param float x: the new x location</span>
<span class="sd">        :param float y: the new y location</span>
<span class="sd">        :returns: the workplane object, with the center adjusted.</span>

<span class="sd">        The current point is set to the new center.</span>
<span class="sd">        This method is useful to adjust the center point after it has been created automatically on</span>
<span class="sd">        a face, but not where you&#39;d like it to be.</span>

<span class="sd">        In this example, we adjust the workplane center to be at the corner of a cube, instead of</span>
<span class="sd">        the center of a face, which is the default::</span>

<span class="sd">            #this workplane is centered at x=0.5,y=0.5, the center of the upper face</span>
<span class="sd">            s = Workplane().box(1,1,1).faces(&quot;&gt;Z&quot;).workplane()</span>

<span class="sd">            s.center(-0.5,-0.5) # move the center to the corner</span>
<span class="sd">            t = s.circle(0.25).extrude(0.2)</span>
<span class="sd">            assert ( t.faces().size() == 9 ) # a cube with a cylindrical nub at the top right corner</span>

<span class="sd">        The result is a cube with a round boss on the corner</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="s2">&quot;Shift local coordinates to the specified location, according to current coordinates&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">setOrigin2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">origin</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">n</span></div>

<div class="viewcode-block" id="Workplane.lineTo"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.lineTo">[docs]</a>    <span class="k">def</span> <span class="nf">lineTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">forConstruction</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a line from the current point to the provided point</span>

<span class="sd">        :param float x: the x point, in workplane plane coordinates</span>
<span class="sd">        :param float y: the y point, in workplane plane coordinates</span>
<span class="sd">        :return: the Workplane object with the current point at the end of the new line</span>

<span class="sd">        see :py:meth:`line` if you want to use relative dimensions to make a line instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">startPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findFromPoint</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>

        <span class="n">endPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">toWorldCoords</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>

        <span class="n">p</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">makeLine</span><span class="p">(</span><span class="n">startPoint</span><span class="p">,</span> <span class="n">endPoint</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">forConstruction</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addPendingEdge</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">p</span><span class="p">])</span></div>

    <span class="c1"># line a specified incremental amount from current point</span>
<div class="viewcode-block" id="Workplane.line"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.line">[docs]</a>    <span class="k">def</span> <span class="nf">line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xDist</span><span class="p">,</span> <span class="n">yDist</span><span class="p">,</span> <span class="n">forConstruction</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a line from the current point to the provided point, using</span>
<span class="sd">        dimensions relative to the current point</span>

<span class="sd">        :param float xDist: x distance from current point</span>
<span class="sd">        :param float yDist: y distance from current point</span>
<span class="sd">        :return: the workplane object with the current point at the end of the new line</span>

<span class="sd">        see :py:meth:`lineTo` if you want to use absolute coordinates to make a line instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findFromPoint</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>  <span class="c1"># return local coordinates</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineTo</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">xDist</span><span class="p">,</span> <span class="n">yDist</span> <span class="o">+</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">forConstruction</span><span class="p">)</span></div>

<div class="viewcode-block" id="Workplane.vLine"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.vLine">[docs]</a>    <span class="k">def</span> <span class="nf">vLine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">forConstruction</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a vertical line from the current point the provided distance</span>

<span class="sd">        :param float distance: (y) distance from current point</span>
<span class="sd">        :return: the workplane object with the current point at the end of the new line</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">forConstruction</span><span class="p">)</span></div>

<div class="viewcode-block" id="Workplane.hLine"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.hLine">[docs]</a>    <span class="k">def</span> <span class="nf">hLine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">forConstruction</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a horizontal line from the current point the provided distance</span>

<span class="sd">        :param float distance: (x) distance from current point</span>
<span class="sd">        :return: the Workplane object with the current point at the end of the new line</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">line</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">forConstruction</span><span class="p">)</span></div>

<div class="viewcode-block" id="Workplane.vLineTo"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.vLineTo">[docs]</a>    <span class="k">def</span> <span class="nf">vLineTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">yCoord</span><span class="p">,</span> <span class="n">forConstruction</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a vertical line from the current point to the provided y coordinate.</span>

<span class="sd">        Useful if it is more convenient to specify the end location rather than distance,</span>
<span class="sd">        as in :py:meth:`vLine`</span>

<span class="sd">        :param float yCoord: y coordinate for the end of the line</span>
<span class="sd">        :return: the Workplane object with the current point at the end of the new line</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findFromPoint</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineTo</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">yCoord</span><span class="p">,</span> <span class="n">forConstruction</span><span class="p">)</span></div>

<div class="viewcode-block" id="Workplane.hLineTo"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.hLineTo">[docs]</a>    <span class="k">def</span> <span class="nf">hLineTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xCoord</span><span class="p">,</span> <span class="n">forConstruction</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a horizontal line from the current point to the provided x coordinate.</span>

<span class="sd">        Useful if it is more convenient to specify the end location rather than distance,</span>
<span class="sd">        as in :py:meth:`hLine`</span>

<span class="sd">        :param float xCoord: x coordinate for the end of the line</span>
<span class="sd">        :return: the Workplane object with the current point at the end of the new line</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findFromPoint</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineTo</span><span class="p">(</span><span class="n">xCoord</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">forConstruction</span><span class="p">)</span></div>

    <span class="c1">#absolute move in current plane, not drawing</span>
<div class="viewcode-block" id="Workplane.moveTo"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.moveTo">[docs]</a>    <span class="k">def</span> <span class="nf">moveTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Move to the specified point, without drawing.</span>

<span class="sd">        :param x: desired x location, in local coordinates</span>
<span class="sd">        :type x: float, or none for zero</span>
<span class="sd">        :param y: desired y location, in local coordinates</span>
<span class="sd">        :type y: float, or none for zero.</span>

<span class="sd">        Not to be confused with :py:meth:`center`, which moves the center of the entire</span>
<span class="sd">        workplane, this method only moves the current point ( and therefore does not affect objects</span>
<span class="sd">        already drawn ).</span>

<span class="sd">        See :py:meth:`move` to do the same thing but using relative dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">newCenter</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">toWorldCoords</span><span class="p">(</span><span class="n">newCenter</span><span class="p">)])</span></div>

    <span class="c1">#relative move in current plane, not drawing</span>
<div class="viewcode-block" id="Workplane.move"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.move">[docs]</a>    <span class="k">def</span> <span class="nf">move</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xDist</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">yDist</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Move the specified distance from the current point, without drawing.</span>

<span class="sd">        :param xDist: desired x distance, in local coordinates</span>
<span class="sd">        :type xDist: float, or none for zero</span>
<span class="sd">        :param yDist: desired y distance, in local coordinates</span>
<span class="sd">        :type yDist: float, or none for zero.</span>

<span class="sd">        Not to be confused with :py:meth:`center`, which moves the center of the entire</span>
<span class="sd">        workplane, this method only moves the current point ( and therefore does not affect objects</span>
<span class="sd">        already drawn ).</span>

<span class="sd">        See :py:meth:`moveTo` to do the same thing but using absolute coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findFromPoint</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">newCenter</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">Vector</span><span class="p">(</span><span class="n">xDist</span><span class="p">,</span> <span class="n">yDist</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">toWorldCoords</span><span class="p">(</span><span class="n">newCenter</span><span class="p">)])</span></div>

<div class="viewcode-block" id="Workplane.spline"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.spline">[docs]</a>    <span class="k">def</span> <span class="nf">spline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">listOfXYTuple</span><span class="p">,</span> <span class="n">forConstruction</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a spline interpolated through the provided points.</span>

<span class="sd">        :param listOfXYTuple: points to interpolate through</span>
<span class="sd">        :type listOfXYTuple: list of 2-tuple</span>
<span class="sd">        :return: a Workplane object with the current point at the end of the spline</span>

<span class="sd">        The spline will begin at the current point, and</span>
<span class="sd">        end with the last point in the XY tuple list</span>

<span class="sd">        This example creates a block with a spline for one side::</span>

<span class="sd">            s = Workplane(Plane.XY())</span>
<span class="sd">            sPnts = [</span>
<span class="sd">                (2.75,1.5),</span>
<span class="sd">                (2.5,1.75),</span>
<span class="sd">                (2.0,1.5),</span>
<span class="sd">                (1.5,1.0),</span>
<span class="sd">                (1.0,1.25),</span>
<span class="sd">                (0.5,1.0),</span>
<span class="sd">                (0,1.0)</span>
<span class="sd">            ]</span>
<span class="sd">            r = s.lineTo(3.0,0).lineTo(3.0,1.0).spline(sPnts).close()</span>
<span class="sd">            r = r.extrude(0.5)</span>

<span class="sd">        *WARNING*  It is fairly easy to create a list of points</span>
<span class="sd">        that cannot be correctly interpreted as a spline.</span>

<span class="sd">        Future Enhancements:</span>
<span class="sd">          * provide access to control points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">gstartPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findFromPoint</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">gEndPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">toWorldCoords</span><span class="p">(</span><span class="n">listOfXYTuple</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="n">vecs</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">toWorldCoords</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">listOfXYTuple</span><span class="p">]</span>
        <span class="n">allPoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">gstartPoint</span><span class="p">]</span> <span class="o">+</span> <span class="n">vecs</span>

        <span class="n">e</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">makeSpline</span><span class="p">(</span><span class="n">allPoints</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">forConstruction</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addPendingEdge</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">e</span><span class="p">])</span></div>

<div class="viewcode-block" id="Workplane.threePointArc"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.threePointArc">[docs]</a>    <span class="k">def</span> <span class="nf">threePointArc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">point1</span><span class="p">,</span> <span class="n">point2</span><span class="p">,</span> <span class="n">forConstruction</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw an arc from the current point, through point1, and ending at point2</span>

<span class="sd">        :param point1: point to draw through</span>
<span class="sd">        :type point1: 2-tuple, in workplane coordinates</span>
<span class="sd">        :param point2: end point for the arc</span>
<span class="sd">        :type point2: 2-tuple, in workplane coordinates</span>
<span class="sd">        :return: a workplane with the current point at the end of the arc</span>

<span class="sd">        Future Enhancements:</span>
<span class="sd">            provide a version that allows an arc using relative measures</span>
<span class="sd">            provide a centerpoint arc</span>
<span class="sd">            provide tangent arcs</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">startPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findFromPoint</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>
        <span class="n">point1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">toWorldCoords</span><span class="p">(</span><span class="n">point1</span><span class="p">)</span>
        <span class="n">point2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">toWorldCoords</span><span class="p">(</span><span class="n">point2</span><span class="p">)</span>

        <span class="n">arc</span> <span class="o">=</span> <span class="n">Edge</span><span class="o">.</span><span class="n">makeThreePointArc</span><span class="p">(</span><span class="n">startPoint</span><span class="p">,</span> <span class="n">point1</span><span class="p">,</span> <span class="n">point2</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">forConstruction</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addPendingEdge</span><span class="p">(</span><span class="n">arc</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">arc</span><span class="p">])</span></div>

<div class="viewcode-block" id="Workplane.sagittaArc"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.sagittaArc">[docs]</a>    <span class="k">def</span> <span class="nf">sagittaArc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endPoint</span><span class="p">,</span> <span class="n">sag</span><span class="p">,</span> <span class="n">forConstruction</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw an arc from the current point to endPoint with an arc defined by the sag (sagitta).</span>

<span class="sd">        :param endPoint: end point for the arc</span>
<span class="sd">        :type endPoint: 2-tuple, in workplane coordinates</span>
<span class="sd">        :param sag: the sagitta of the arc</span>
<span class="sd">        :type sag: float, perpendicular distance from arc center to arc baseline.</span>
<span class="sd">        :return: a workplane with the current point at the end of the arc</span>

<span class="sd">        The sagitta is the distance from the center of the arc to the arc base.</span>
<span class="sd">        Given that a closed contour is drawn clockwise;</span>
<span class="sd">        A positive sagitta means convex arc and negative sagitta means concave arc.</span>
<span class="sd">        See &quot;https://en.wikipedia.org/wiki/Sagitta_(geometry)&quot; for more information.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">startPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findFromPoint</span><span class="p">(</span><span class="n">useLocalCoords</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">endPoint</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">endPoint</span><span class="p">)</span>
        <span class="n">midPoint</span> <span class="o">=</span> <span class="n">endPoint</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">startPoint</span><span class="p">)</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span>

        <span class="n">sagVector</span> <span class="o">=</span> <span class="n">endPoint</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">startPoint</span><span class="p">)</span><span class="o">.</span><span class="n">normalized</span><span class="p">()</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">sag</span><span class="p">))</span>
        <span class="k">if</span><span class="p">(</span><span class="n">sag</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">sagVector</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">sagVector</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="o">-</span><span class="n">sagVector</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="n">sagVector</span><span class="o">.</span><span class="n">x</span> <span class="c1"># Rotate sagVector +90 deg</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sagVector</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="n">sagVector</span><span class="o">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">sagVector</span><span class="o">.</span><span class="n">y</span><span class="p">,</span> <span class="o">-</span><span class="n">sagVector</span><span class="o">.</span><span class="n">x</span> <span class="c1"># Rotate sagVector -90 deg</span>

        <span class="n">sagPoint</span> <span class="o">=</span> <span class="n">midPoint</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">sagVector</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">threePointArc</span><span class="p">(</span><span class="n">sagPoint</span><span class="p">,</span> <span class="n">endPoint</span><span class="p">,</span> <span class="n">forConstruction</span><span class="p">)</span></div>

<div class="viewcode-block" id="Workplane.radiusArc"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.radiusArc">[docs]</a>    <span class="k">def</span> <span class="nf">radiusArc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">endPoint</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">forConstruction</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Draw an arc from the current point to endPoint with an arc defined by the sag (sagitta).</span>

<span class="sd">        :param endPoint: end point for the arc</span>
<span class="sd">        :type endPoint: 2-tuple, in workplane coordinates</span>
<span class="sd">        :param radius: the radius of the arc</span>
<span class="sd">        :type radius: float, the radius of the arc between start point and end point.</span>
<span class="sd">        :return: a workplane with the current point at the end of the arc</span>

<span class="sd">        Given that a closed contour is drawn clockwise;</span>
<span class="sd">        A positive radius means convex arc and negative radius means concave arc.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">startPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findFromPoint</span><span class="p">(</span><span class="n">useLocalCoords</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">endPoint</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">endPoint</span><span class="p">)</span>

        <span class="c1"># Calculate the sagitta from the radius</span>
        <span class="n">length</span> <span class="o">=</span> <span class="n">endPoint</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">startPoint</span><span class="p">)</span><span class="o">.</span><span class="n">Length</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sag</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">radius</span><span class="p">)</span> <span class="o">-</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">radius</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="n">length</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Arc radius is not large enough to reach the end point.&quot;</span><span class="p">)</span>

        <span class="c1"># Return a sagittaArc</span>
        <span class="k">if</span> <span class="n">radius</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sagittaArc</span><span class="p">(</span><span class="n">endPoint</span><span class="p">,</span> <span class="n">sag</span><span class="p">,</span> <span class="n">forConstruction</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sagittaArc</span><span class="p">(</span><span class="n">endPoint</span><span class="p">,</span> <span class="o">-</span><span class="n">sag</span><span class="p">,</span> <span class="n">forConstruction</span><span class="p">)</span></div>

<div class="viewcode-block" id="Workplane.rotateAndCopy"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.rotateAndCopy">[docs]</a>    <span class="k">def</span> <span class="nf">rotateAndCopy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">matrix</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a copy of all edges on the stack, rotates them according to the</span>
<span class="sd">        provided matrix, and then attempts to consolidate them into a single wire.</span>

<span class="sd">        :param matrix: a 4xr transformation matrix, in global coordinates</span>
<span class="sd">        :type matrix: a FreeCAD Base.Matrix object</span>
<span class="sd">        :return: a CadQuery object  with consolidated wires, and any originals on the stack.</span>

<span class="sd">        The most common use case is to create a set of open edges, and then mirror them</span>
<span class="sd">        around either the X or Y axis to complete a closed shape.</span>

<span class="sd">        see :py:meth:`mirrorX` and :py:meth:`mirrorY` to mirror about the global X and Y axes</span>
<span class="sd">        see :py:meth:`mirrorX` and for an example</span>

<span class="sd">        Future Enhancements:</span>
<span class="sd">            faster implementation: this one transforms 3 times to accomplish the result</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#convert edges to a wire, if there are pending edges</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wire</span><span class="p">(</span><span class="n">forConstruction</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

        <span class="c1">#attempt to consolidate wires together.</span>
        <span class="n">consolidated</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">consolidateWires</span><span class="p">()</span>

        <span class="n">rotatedWires</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">rotateShapes</span><span class="p">(</span><span class="n">consolidated</span><span class="o">.</span><span class="n">wires</span><span class="p">()</span><span class="o">.</span><span class="n">vals</span><span class="p">(),</span> <span class="n">matrix</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">rotatedWires</span><span class="p">:</span>
            <span class="n">consolidated</span><span class="o">.</span><span class="n">objects</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
            <span class="n">consolidated</span><span class="o">.</span><span class="n">_addPendingWire</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

        <span class="c1">#attempt again to consolidate all of the wires</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">consolidated</span><span class="o">.</span><span class="n">consolidateWires</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">c</span></div>

<div class="viewcode-block" id="Workplane.mirrorY"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.mirrorY">[docs]</a>    <span class="k">def</span> <span class="nf">mirrorY</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mirror entities around the y axis of the workplane plane.</span>

<span class="sd">        :return: a new object with any free edges consolidated into as few wires as possible.</span>

<span class="sd">        All free edges are collected into a wire, and then the wire is mirrored,</span>
<span class="sd">        and finally joined into a new wire</span>

<span class="sd">        Typically used to make creating wires with symmetry easier. This line of code::</span>

<span class="sd">             s = Workplane().lineTo(2,2).threePointArc((3,1),(2,0)).mirrorX().extrude(0.25)</span>

<span class="sd">        Produces a flat, heart shaped object</span>

<span class="sd">        Future Enhancements:</span>
<span class="sd">            mirrorX().mirrorY() should work but doesnt, due to some FreeCAD weirdness</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tm</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">()</span>
        <span class="n">tm</span><span class="o">.</span><span class="n">rotateY</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotateAndCopy</span><span class="p">(</span><span class="n">tm</span><span class="p">)</span></div>

<div class="viewcode-block" id="Workplane.mirrorX"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.mirrorX">[docs]</a>    <span class="k">def</span> <span class="nf">mirrorX</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Mirror entities around the x axis of the workplane plane.</span>

<span class="sd">        :return: a new object with any free edges consolidated into as few wires as possible.</span>

<span class="sd">        All free edges are collected into a wire, and then the wire is mirrored,</span>
<span class="sd">        and finally joined into a new wire</span>

<span class="sd">        Typically used to make creating wires with symmetry easier.</span>

<span class="sd">        Future Enhancements:</span>
<span class="sd">            mirrorX().mirrorY() should work but doesnt, due to some FreeCAD weirdness</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tm</span> <span class="o">=</span> <span class="n">Matrix</span><span class="p">()</span>
        <span class="n">tm</span><span class="o">.</span><span class="n">rotateX</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotateAndCopy</span><span class="p">(</span><span class="n">tm</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_addPendingEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">edge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queues an edge for later combination into a wire.</span>

<span class="sd">        :param edge:</span>
<span class="sd">        :return:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">pendingEdges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">firstPoint</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">firstPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">toLocalCoords</span><span class="p">(</span><span class="n">edge</span><span class="o">.</span><span class="n">startPoint</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_addPendingWire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">wire</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Queue a Wire for later extrusion</span>

<span class="sd">        Internal Processing Note.  In FreeCAD, edges--&gt;wires--&gt;faces--&gt;solids.</span>

<span class="sd">        but users do not normally care about these distinctions.  Users &#39;think&#39; in terms</span>
<span class="sd">        of edges, and solids.</span>

<span class="sd">        CadQuery tracks edges as they are drawn, and automatically combines them into wires</span>
<span class="sd">        when the user does an operation that needs it.</span>

<span class="sd">        Similarly, cadQuery tracks pending wires, and automatically combines them into faces</span>
<span class="sd">        when necessary to make a solid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">pendingWires</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">wire</span><span class="p">)</span>

<div class="viewcode-block" id="Workplane.consolidateWires"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.consolidateWires">[docs]</a>    <span class="k">def</span> <span class="nf">consolidateWires</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempt to consolidate wires on the stack into a single.</span>
<span class="sd">        If possible, a new object with the results are returned.</span>
<span class="sd">        if not possible, the wires remain separated</span>

<span class="sd">        FreeCAD has a bug in Part.Wire([]) which does not create wires/edges properly sometimes</span>
<span class="sd">        Additionally, it has a bug where a profile composed of two wires ( rather than one )</span>
<span class="sd">        also does not work properly. Together these are a real problem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wires</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wires</span><span class="p">()</span><span class="o">.</span><span class="n">vals</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">wires</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="c1">#TODO: this makes the assumption that either all wires could be combined, or none.</span>
        <span class="c1">#in reality trying each combination of wires is probably not reasonable anyway</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">Wire</span><span class="o">.</span><span class="n">combine</span><span class="p">(</span><span class="n">wires</span><span class="p">)</span>

        <span class="c1">#ok this is a little tricky. if we consolidate wires, we have to actually</span>
        <span class="c1">#modify the pendingWires collection to remove the original ones, and replace them</span>
        <span class="c1">#with the consolidate done</span>
        <span class="c1">#since we are already assuming that all wires could be consolidated, its easy, we just</span>
        <span class="c1">#clear the pending wire list</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">w</span><span class="p">])</span>
        <span class="n">r</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">pendingWires</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">r</span><span class="o">.</span><span class="n">_addPendingWire</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">r</span></div>

<div class="viewcode-block" id="Workplane.wire"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.wire">[docs]</a>    <span class="k">def</span> <span class="nf">wire</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forConstruction</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a CQ object with all pending edges connected into a wire.</span>

<span class="sd">        All edges on the stack that can be combined will be combined into a single wire object,</span>
<span class="sd">        and other objects will remain on the stack unmodified</span>

<span class="sd">        :param forConstruction: whether the wire should be used to make a solid, or if it is just</span>
<span class="sd">            for reference</span>
<span class="sd">        :type forConstruction: boolean. true if the object is only for reference</span>

<span class="sd">        This method is primarily of use to plugin developers making utilities for 2-d construction.</span>
<span class="sd">        This method should be called when a user operation implies that 2-d construction is</span>
<span class="sd">        finished, and we are ready to begin working in 3d</span>

<span class="sd">        SEE &#39;2-d construction concepts&#39; for a more detailed explanation of how CadQuery handles</span>
<span class="sd">        edges, wires, etc</span>

<span class="sd">        Any non edges will still remain.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">pendingEdges</span>

        <span class="c1">#do not consolidate if there are no free edges</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">pendingEdges</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">others</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Edge</span><span class="p">:</span>
                <span class="n">others</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>


        <span class="n">w</span> <span class="o">=</span> <span class="n">Wire</span><span class="o">.</span><span class="n">assembleEdges</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">forConstruction</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_addPendingWire</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">(</span><span class="n">others</span> <span class="o">+</span> <span class="p">[</span><span class="n">w</span><span class="p">])</span></div>

<div class="viewcode-block" id="Workplane.each"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.each">[docs]</a>    <span class="k">def</span> <span class="nf">each</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callBackFunction</span><span class="p">,</span> <span class="n">useLocalCoordinates</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Runs the provided function on each value in the stack, and collects the return values into</span>
<span class="sd">        a new CQ object.</span>

<span class="sd">        Special note: a newly created workplane always has its center point as its only stack item</span>

<span class="sd">        :param callBackFunction: the function to call for each item on the current stack.</span>
<span class="sd">        :param useLocalCoordinates: should  values be converted from local coordinates first?</span>
<span class="sd">        :type useLocalCoordinates: boolean</span>

<span class="sd">        The callback function must accept one argument, which is the item on the stack, and return</span>
<span class="sd">        one object, which is collected. If the function returns None, nothing is added to the stack.</span>
<span class="sd">        The object passed into the callBackFunction is potentially transformed to local coordinates,</span>
<span class="sd">        if useLocalCoordinates is true</span>

<span class="sd">        useLocalCoordinates is very useful for plugin developers.</span>

<span class="sd">        If false, the callback function is assumed to be working in global coordinates.  Objects</span>
<span class="sd">        created are added as-is, and objects passed into the function are sent in using global</span>
<span class="sd">        coordinates</span>

<span class="sd">        If true, the calling function is assumed to be  working in local coordinates.  Objects are</span>
<span class="sd">        transformed to local coordinates before they are passed into the callback method, and result</span>
<span class="sd">        objects are transformed to global coordinates after they are returned.</span>

<span class="sd">        This allows plugin developers to create objects in local coordinates, without worrying</span>
<span class="sd">        about the fact that the working plane is different than the global coordinate system.</span>


<span class="sd">        TODO: wrapper object for Wire will clean up forConstruction flag everywhere</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">results</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>

            <span class="k">if</span> <span class="n">useLocalCoordinates</span><span class="p">:</span>
                <span class="c1">#TODO: this needs to work for all types of objects, not just vectors!</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">callBackFunction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">toLocalCoords</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">transformShape</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">rG</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">callBackFunction</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">==</span> <span class="n">Wire</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">r</span><span class="o">.</span><span class="n">forConstruction</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_addPendingWire</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

            <span class="n">results</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">(</span><span class="n">results</span><span class="p">)</span></div>

<div class="viewcode-block" id="Workplane.eachpoint"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.eachpoint">[docs]</a>    <span class="k">def</span> <span class="nf">eachpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callbackFunction</span><span class="p">,</span> <span class="n">useLocalCoordinates</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as each(), except each item on the stack is converted into a point before it</span>
<span class="sd">        is passed into the callback function.</span>

<span class="sd">        :return: CadQuery object which contains a list of  vectors (points ) on its stack.</span>

<span class="sd">        :param useLocalCoordinates: should points be in local or global coordinates</span>
<span class="sd">        :type useLocalCoordinates: boolean</span>

<span class="sd">        The resulting object has a point on the stack for each object on the original stack.</span>
<span class="sd">        Vertices and points remain a point.  Faces, Wires, Solids, Edges, and Shells are converted</span>
<span class="sd">        to a point by using their center of mass.</span>

<span class="sd">        If the stack has zero length, a single point is returned, which is the center of the current</span>
<span class="sd">        workplane/coordinate system</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#convert stack to a list of points</span>
        <span class="n">pnts</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1">#nothing on the stack. here, we&#39;ll assume we should operate with the</span>
            <span class="c1">#origin as the context point</span>
            <span class="n">pnts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">origin</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>

            <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">:</span>
                <span class="n">pnts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">Center</span><span class="p">())</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">(</span><span class="n">pnts</span><span class="p">)</span><span class="o">.</span><span class="n">each</span><span class="p">(</span><span class="n">callbackFunction</span><span class="p">,</span> <span class="n">useLocalCoordinates</span><span class="p">)</span></div>

<div class="viewcode-block" id="Workplane.rect"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.rect">[docs]</a>    <span class="k">def</span> <span class="nf">rect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xLen</span><span class="p">,</span> <span class="n">yLen</span><span class="p">,</span> <span class="n">centered</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">forConstruction</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a rectangle for each item on the stack.</span>

<span class="sd">        :param xLen: length in xDirection ( in workplane coordinates )</span>
<span class="sd">        :type xLen: float &gt; 0</span>
<span class="sd">        :param yLen: length in yDirection ( in workplane coordinates )</span>
<span class="sd">        :type yLen: float &gt; 0</span>
<span class="sd">        :param boolean centered: true if the rect is centered on the reference point, false if the</span>
<span class="sd">            lower-left is on the reference point</span>
<span class="sd">        :param forConstruction: should the new wires be reference geometry only?</span>
<span class="sd">        :type forConstruction: true if the wires are for reference, false if they are creating part</span>
<span class="sd">            geometry</span>
<span class="sd">        :return: a new CQ object with the created wires on the stack</span>

<span class="sd">        A common use case is to use a for-construction rectangle to define the centers of a hole</span>
<span class="sd">        pattern::</span>

<span class="sd">            s = Workplane().rect(4.0,4.0,forConstruction=True).vertices().circle(0.25)</span>

<span class="sd">        Creates 4 circles at the corners of a square centered on the origin.</span>

<span class="sd">        Future Enhancements:</span>
<span class="sd">            better way to handle forConstruction</span>
<span class="sd">            project points not in the workplane plane onto the workplane plane</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">makeRectangleWire</span><span class="p">(</span><span class="n">pnt</span><span class="p">):</span>
            <span class="c1"># Here pnt is in local coordinates due to useLocalCoords=True</span>
            <span class="c1"># (xc,yc,zc) = pnt.toTuple()</span>
            <span class="k">if</span> <span class="n">centered</span><span class="p">:</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">pnt</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">xLen</span><span class="o">/-</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">yLen</span><span class="o">/-</span><span class="mf">2.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">pnt</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">xLen</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">yLen</span><span class="o">/-</span><span class="mf">2.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">p3</span> <span class="o">=</span> <span class="n">pnt</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">xLen</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">yLen</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">p4</span> <span class="o">=</span> <span class="n">pnt</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">xLen</span><span class="o">/-</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">yLen</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p1</span> <span class="o">=</span> <span class="n">pnt</span>
                <span class="n">p2</span> <span class="o">=</span> <span class="n">pnt</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">xLen</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">p3</span> <span class="o">=</span> <span class="n">pnt</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="n">xLen</span><span class="p">,</span> <span class="n">yLen</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">p4</span> <span class="o">=</span> <span class="n">pnt</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">Vector</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">yLen</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>

            <span class="n">w</span> <span class="o">=</span> <span class="n">Wire</span><span class="o">.</span><span class="n">makePolygon</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">,</span> <span class="n">p3</span><span class="p">,</span> <span class="n">p4</span><span class="p">,</span> <span class="n">p1</span><span class="p">],</span> <span class="n">forConstruction</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">w</span>
            <span class="c1">#return Part.makePolygon([p1,p2,p3,p4,p1])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eachpoint</span><span class="p">(</span><span class="n">makeRectangleWire</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span></div>

    <span class="c1">#circle from current point</span>
<div class="viewcode-block" id="Workplane.circle"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.circle">[docs]</a>    <span class="k">def</span> <span class="nf">circle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">forConstruction</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a circle for each item on the stack.</span>

<span class="sd">        :param radius: radius of the circle</span>
<span class="sd">        :type radius: float &gt; 0</span>
<span class="sd">        :param forConstruction: should the new wires be reference geometry only?</span>
<span class="sd">        :type forConstruction: true if the wires are for reference, false if they are creating</span>
<span class="sd">            part geometry</span>
<span class="sd">        :return: a new CQ object with the created wires on the stack</span>

<span class="sd">        A common use case is to use a for-construction rectangle to define the centers of a</span>
<span class="sd">        hole pattern::</span>

<span class="sd">            s = Workplane().rect(4.0,4.0,forConstruction=True).vertices().circle(0.25)</span>

<span class="sd">        Creates 4 circles at the corners of a square centered on the origin. Another common case is</span>
<span class="sd">        to use successive circle() calls to create concentric circles.  This works because the</span>
<span class="sd">        center of a circle is its reference point::</span>

<span class="sd">            s = Workplane().circle(2.0).circle(1.0)</span>

<span class="sd">        Creates two concentric circles, which when extruded will form a ring.</span>

<span class="sd">        Future Enhancements:</span>
<span class="sd">            better way to handle forConstruction</span>
<span class="sd">            project points not in the workplane plane onto the workplane plane</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">makeCircleWire</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="n">cir</span> <span class="o">=</span> <span class="n">Wire</span><span class="o">.</span><span class="n">makeCircle</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">Vector</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">cir</span><span class="o">.</span><span class="n">forConstruction</span> <span class="o">=</span> <span class="n">forConstruction</span>
            <span class="k">return</span> <span class="n">cir</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eachpoint</span><span class="p">(</span><span class="n">makeCircleWire</span><span class="p">,</span> <span class="n">useLocalCoordinates</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Workplane.polygon"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.polygon">[docs]</a>    <span class="k">def</span> <span class="nf">polygon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nSides</span><span class="p">,</span> <span class="n">diameter</span><span class="p">,</span> <span class="n">forConstruction</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a polygon inscribed in a circle of the specified diameter for each point on</span>
<span class="sd">        the stack</span>

<span class="sd">        The first vertex is always oriented in the x direction.</span>

<span class="sd">        :param nSides: number of sides, must be &gt; 3</span>
<span class="sd">        :param diameter: the size of the circle the polygon is inscribed into</span>
<span class="sd">        :return: a polygon wire</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">_makePolygon</span><span class="p">(</span><span class="n">center</span><span class="p">):</span>
            <span class="c1">#pnt is a vector in local coordinates</span>
            <span class="n">angle</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">nSides</span>
            <span class="n">pnts</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nSides</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">pnts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">center</span> <span class="o">+</span> <span class="n">Vector</span><span class="p">((</span><span class="n">diameter</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="o">*</span><span class="n">i</span><span class="p">)),</span>
                                            <span class="p">(</span><span class="n">diameter</span> <span class="o">/</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="o">*</span><span class="n">i</span><span class="p">)),</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">Wire</span><span class="o">.</span><span class="n">makePolygon</span><span class="p">(</span><span class="n">pnts</span><span class="p">,</span> <span class="n">forConstruction</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">eachpoint</span><span class="p">(</span><span class="n">_makePolygon</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Workplane.polyline"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.polyline">[docs]</a>    <span class="k">def</span> <span class="nf">polyline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">listOfXYTuple</span><span class="p">,</span> <span class="n">forConstruction</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a polyline from a list of points</span>

<span class="sd">        :param listOfXYTuple: a list of points in Workplane coordinates</span>
<span class="sd">        :type listOfXYTuple: list of 2-tuples</span>
<span class="sd">        :param forConstruction: whether or not the edges are used for reference</span>
<span class="sd">        :type forConstruction: true if the edges are for reference, false if they are for creating geometry</span>
<span class="sd">            part geometry</span>
<span class="sd">        :return: a new CQ object with a list of edges on the stack</span>

<span class="sd">        *NOTE* most commonly, the resulting wire should be closed.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Our list of new edges that will go into a new CQ object</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># The very first startPoint comes from our original object, but not after that</span>
        <span class="n">startPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findFromPoint</span><span class="p">(</span><span class="bp">False</span><span class="p">)</span>

        <span class="c1"># Draw a line for each set of points, starting from the from-point of the original CQ object</span>
        <span class="k">for</span> <span class="n">curTuple</span> <span class="ow">in</span> <span class="n">listOfXYTuple</span><span class="p">:</span>
            <span class="n">endPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">toWorldCoords</span><span class="p">(</span><span class="n">curTuple</span><span class="p">)</span>

            <span class="n">edges</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Edge</span><span class="o">.</span><span class="n">makeLine</span><span class="p">(</span><span class="n">startPoint</span><span class="p">,</span> <span class="n">endPoint</span><span class="p">))</span>

            <span class="c1"># We need to move the start point for the next line that we draw or we get stuck at the same startPoint</span>
            <span class="n">startPoint</span> <span class="o">=</span> <span class="n">endPoint</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">forConstruction</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_addPendingEdge</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span></div>

<div class="viewcode-block" id="Workplane.close"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        End 2-d construction, and attempt to build a closed wire.</span>

<span class="sd">        :return: a CQ object with a completed wire on the stack, if possible.</span>

<span class="sd">        After 2-d drafting with lineTo,threePointArc, and polyline, it is necessary</span>
<span class="sd">        to convert the edges produced by these into one or more wires.</span>

<span class="sd">        When a set of edges is closed, cadQuery assumes it is safe to build the group of edges</span>
<span class="sd">        into a wire.  This example builds a simple triangular prism::</span>

<span class="sd">            s = Workplane().lineTo(1,0).lineTo(1,1).close().extrude(0.2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">endPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_findFromPoint</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">startPoint</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">firstPoint</span>

        <span class="c1"># Check if there is a distance between startPoint and endPoint</span>
        <span class="c1"># that is larger than what is considered a numerical error.</span>
        <span class="c1"># If so; add a line segment between endPoint and startPoint</span>
        <span class="k">if</span> <span class="n">endPoint</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">startPoint</span><span class="p">)</span><span class="o">.</span><span class="n">Length</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lineTo</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">firstPoint</span><span class="o">.</span><span class="n">x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">firstPoint</span><span class="o">.</span><span class="n">y</span><span class="p">)</span>

        <span class="c1"># Need to reset the first point after closing a wire</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">firstPoint</span><span class="o">=</span><span class="bp">None</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">wire</span><span class="p">()</span></div>

<div class="viewcode-block" id="Workplane.largestDimension"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.largestDimension">[docs]</a>    <span class="k">def</span> <span class="nf">largestDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the largest dimension in the stack.</span>
<span class="sd">        Used internally to create thru features, this is how you can compute</span>
<span class="sd">        how long or wide a feature must be to make sure to cut through all of the material</span>
<span class="sd">        :return: A value representing the largest dimension of the first solid on the stack</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#TODO: this implementation is naive and returns the dims of the first solid... most of</span>
        <span class="c1">#TODO: the time this works. but a stronger implementation would be to search all solids.</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findSolid</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">s</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">s</span><span class="o">.</span><span class="n">BoundingBox</span><span class="p">()</span><span class="o">.</span><span class="n">DiagonalLength</span> <span class="o">*</span> <span class="mf">5.0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span></div>

<div class="viewcode-block" id="Workplane.cutEach"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.cutEach">[docs]</a>    <span class="k">def</span> <span class="nf">cutEach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fcn</span><span class="p">,</span> <span class="n">useLocalCoords</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Evaluates the provided function at each point on the stack (ie, eachpoint)</span>
<span class="sd">        and then cuts the result from the context solid.</span>
<span class="sd">        :param fcn: a function suitable for use in the eachpoint method: ie, that accepts a vector</span>
<span class="sd">        :param useLocalCoords: same as for :py:meth:`eachpoint`</span>
<span class="sd">        :param boolean clean: call :py:meth:`clean` afterwards to have a clean shape</span>
<span class="sd">        :return: a CQ object that contains the resulting solid</span>
<span class="sd">        :raises: an error if there is not a context solid to cut from</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ctxSolid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findSolid</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ctxSolid</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Must have a solid in the chain to cut from!&quot;</span><span class="p">)</span>

        <span class="c1">#will contain all of the counterbores as a single compound</span>
        <span class="n">results</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eachpoint</span><span class="p">(</span><span class="n">fcn</span><span class="p">,</span> <span class="n">useLocalCoords</span><span class="p">)</span><span class="o">.</span><span class="n">vals</span><span class="p">()</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">ctxSolid</span>
        <span class="k">for</span> <span class="n">cb</span> <span class="ow">in</span> <span class="n">results</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">cb</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">clean</span><span class="p">:</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>

        <span class="n">ctxSolid</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">wrapped</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">s</span><span class="p">])</span></div>

    <span class="c1">#but parameter list is different so a simple function pointer wont work</span>
<div class="viewcode-block" id="Workplane.cboreHole"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.cboreHole">[docs]</a>    <span class="k">def</span> <span class="nf">cboreHole</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diameter</span><span class="p">,</span> <span class="n">cboreDiameter</span><span class="p">,</span> <span class="n">cboreDepth</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a counterbored hole for each item on the stack.</span>

<span class="sd">        :param diameter: the diameter of the hole</span>
<span class="sd">        :type diameter: float &gt; 0</span>
<span class="sd">        :param cboreDiameter: the diameter of the cbore</span>
<span class="sd">        :type cboreDiameter: float &gt; 0 and &gt; diameter</span>
<span class="sd">        :param cboreDepth: depth of the counterbore</span>
<span class="sd">        :type cboreDepth: float &gt; 0</span>
<span class="sd">        :param depth: the depth of the hole</span>
<span class="sd">        :type depth: float &gt; 0 or None to drill thru the entire part.</span>
<span class="sd">        :param boolean clean: call :py:meth:`clean` afterwards to have a clean shape</span>

<span class="sd">        The surface of the hole is at the current workplane plane.</span>

<span class="sd">        One hole is created for each item on the stack.  A very common use case is to use a</span>
<span class="sd">        construction rectangle to define the centers of a set of holes, like so::</span>

<span class="sd">                s = Workplane(Plane.XY()).box(2,4,0.5).faces(&quot;&gt;Z&quot;).workplane()\</span>
<span class="sd">                    .rect(1.5,3.5,forConstruction=True)\</span>
<span class="sd">                    .vertices().cboreHole(0.125, 0.25,0.125,depth=None)</span>

<span class="sd">        This sample creates a plate with a set of holes at the corners.</span>

<span class="sd">        **Plugin Note**: this is one example of the power of plugins. Counterbored holes are quite</span>
<span class="sd">        time consuming to create, but are quite easily defined by users.</span>

<span class="sd">        see :py:meth:`cskHole` to make countersinks instead of counterbores</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">largestDimension</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">_makeCbore</span><span class="p">(</span><span class="n">center</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Makes a single hole with counterbore at the supplied point</span>
<span class="sd">            returns a solid suitable for subtraction</span>
<span class="sd">            pnt is in local coordinates</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">boreDir</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">#first make the hole</span>
            <span class="n">hole</span> <span class="o">=</span> <span class="n">Solid</span><span class="o">.</span><span class="n">makeCylinder</span><span class="p">(</span><span class="n">diameter</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">boreDir</span><span class="p">)</span>  <span class="c1"># local coordianates!</span>

            <span class="c1">#add the counter bore</span>
            <span class="n">cbore</span> <span class="o">=</span> <span class="n">Solid</span><span class="o">.</span><span class="n">makeCylinder</span><span class="p">(</span><span class="n">cboreDiameter</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">cboreDepth</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">boreDir</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">hole</span><span class="o">.</span><span class="n">fuse</span><span class="p">(</span><span class="n">cbore</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">r</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutEach</span><span class="p">(</span><span class="n">_makeCbore</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="n">clean</span><span class="p">)</span></div>

    <span class="c1">#TODO: almost all code duplicated!</span>
    <span class="c1">#but parameter list is different so a simple function pointer wont work</span>
<div class="viewcode-block" id="Workplane.cskHole"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.cskHole">[docs]</a>    <span class="k">def</span> <span class="nf">cskHole</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diameter</span><span class="p">,</span> <span class="n">cskDiameter</span><span class="p">,</span> <span class="n">cskAngle</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a countersunk hole for each item on the stack.</span>

<span class="sd">        :param diameter: the diameter of the hole</span>
<span class="sd">        :type diameter: float &gt; 0</span>
<span class="sd">        :param cskDiameter: the diameter of the countersink</span>
<span class="sd">        :type cskDiameter: float &gt; 0 and &gt; diameter</span>
<span class="sd">        :param cskAngle: angle of the countersink, in degrees ( 82 is common )</span>
<span class="sd">        :type cskAngle: float &gt; 0</span>
<span class="sd">        :param depth: the depth of the hole</span>
<span class="sd">        :type depth: float &gt; 0 or None to drill thru the entire part.</span>
<span class="sd">        :param boolean clean: call :py:meth:`clean` afterwards to have a clean shape</span>

<span class="sd">        The surface of the hole is at the current workplane.</span>

<span class="sd">        One hole is created for each item on the stack.  A very common use case is to use a</span>
<span class="sd">        construction rectangle to define the centers of a set of holes, like so::</span>

<span class="sd">                s = Workplane(Plane.XY()).box(2,4,0.5).faces(&quot;&gt;Z&quot;).workplane()\</span>
<span class="sd">                    .rect(1.5,3.5,forConstruction=True)\</span>
<span class="sd">                    .vertices().cskHole(0.125, 0.25,82,depth=None)</span>

<span class="sd">        This sample creates a plate with a set of holes at the corners.</span>

<span class="sd">        **Plugin Note**: this is one example of the power of plugins. CounterSunk holes are quite</span>
<span class="sd">        time consuming to create, but are quite easily defined by users.</span>

<span class="sd">        see :py:meth:`cboreHole` to make counterbores instead of countersinks</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">depth</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">largestDimension</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">_makeCsk</span><span class="p">(</span><span class="n">center</span><span class="p">):</span>
            <span class="c1">#center is in local coordinates</span>

            <span class="n">boreDir</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1">#first make the hole</span>
            <span class="n">hole</span> <span class="o">=</span> <span class="n">Solid</span><span class="o">.</span><span class="n">makeCylinder</span><span class="p">(</span><span class="n">diameter</span><span class="o">/</span><span class="mf">2.0</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">boreDir</span><span class="p">)</span>  <span class="c1"># local coords!</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">cskDiameter</span> <span class="o">/</span> <span class="mf">2.0</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">r</span> <span class="o">/</span> <span class="n">math</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">cskAngle</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">))</span>
            <span class="n">csk</span> <span class="o">=</span> <span class="n">Solid</span><span class="o">.</span><span class="n">makeCone</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">h</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">boreDir</span><span class="p">)</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">hole</span><span class="o">.</span><span class="n">fuse</span><span class="p">(</span><span class="n">csk</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">r</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutEach</span><span class="p">(</span><span class="n">_makeCsk</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="n">clean</span><span class="p">)</span></div>

    <span class="c1">#TODO: almost all code duplicated!</span>
    <span class="c1">#but parameter list is different so a simple function pointer wont work</span>
<div class="viewcode-block" id="Workplane.hole"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.hole">[docs]</a>    <span class="k">def</span> <span class="nf">hole</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">diameter</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a hole for each item on the stack.</span>

<span class="sd">        :param diameter: the diameter of the hole</span>
<span class="sd">        :type diameter: float &gt; 0</span>
<span class="sd">        :param depth: the depth of the hole</span>
<span class="sd">        :type depth: float &gt; 0 or None to drill thru the entire part.</span>
<span class="sd">        :param boolean clean: call :py:meth:`clean` afterwards to have a clean shape</span>

<span class="sd">        The surface of the hole is at the current workplane.</span>

<span class="sd">        One hole is created for each item on the stack.  A very common use case is to use a</span>
<span class="sd">        construction rectangle to define the centers of a set of holes, like so::</span>

<span class="sd">                s = Workplane(Plane.XY()).box(2,4,0.5).faces(&quot;&gt;Z&quot;).workplane()\</span>
<span class="sd">                    .rect(1.5,3.5,forConstruction=True)\</span>
<span class="sd">                    .vertices().hole(0.125, 0.25,82,depth=None)</span>

<span class="sd">        This sample creates a plate with a set of holes at the corners.</span>

<span class="sd">        **Plugin Note**: this is one example of the power of plugins. CounterSunk holes are quite</span>
<span class="sd">        time consuming to create, but are quite easily defined by users.</span>

<span class="sd">        see :py:meth:`cboreHole` and :py:meth:`cskHole` to make counterbores or countersinks</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">depth</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">largestDimension</span><span class="p">()</span>

        <span class="k">def</span> <span class="nf">_makeHole</span><span class="p">(</span><span class="n">center</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Makes a single hole with counterbore at the supplied point</span>
<span class="sd">            returns a solid suitable for subtraction</span>
<span class="sd">            pnt is in local coordinates</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">boreDir</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1">#first make the hole</span>
            <span class="n">hole</span> <span class="o">=</span> <span class="n">Solid</span><span class="o">.</span><span class="n">makeCylinder</span><span class="p">(</span><span class="n">diameter</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">boreDir</span><span class="p">)</span>  <span class="c1"># local coordinates!</span>
            <span class="k">return</span> <span class="n">hole</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutEach</span><span class="p">(</span><span class="n">_makeHole</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="n">clean</span><span class="p">)</span></div>

    <span class="c1">#TODO: duplicated code with _extrude and extrude</span>
<div class="viewcode-block" id="Workplane.twistExtrude"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.twistExtrude">[docs]</a>    <span class="k">def</span> <span class="nf">twistExtrude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">angleDegrees</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extrudes a wire in the direction normal to the plane, but also twists by the specified</span>
<span class="sd">        angle over the length of the extrusion</span>

<span class="sd">        The center point of the rotation will be the center of the workplane</span>

<span class="sd">        See extrude for more details, since this method is the same except for the the addition</span>
<span class="sd">        of the angle. In fact, if angle=0, the result is the same as a linear extrude.</span>

<span class="sd">        **NOTE**  This method can create complex calculations, so be careful using it with</span>
<span class="sd">        complex geometries</span>

<span class="sd">        :param distance: the distance to extrude normal to the workplane</span>
<span class="sd">        :param angle: angline ( in degrees) to rotate through the extrusion</span>
<span class="sd">        :param boolean combine: True to combine the resulting solid with parent solids if found.</span>
<span class="sd">        :param boolean clean: call :py:meth:`clean` afterwards to have a clean shape</span>
<span class="sd">        :return: a CQ object with the resulting solid selected.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#group wires together into faces based on which ones are inside the others</span>
        <span class="c1">#result is a list of lists</span>
        <span class="n">wireSets</span> <span class="o">=</span> <span class="n">sortWiresByBuildOrder</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">pendingWires</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span> <span class="p">[])</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">pendingWires</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># now all of the wires have been used to create an extrusion</span>

        <span class="c1">#compute extrusion vector and extrude</span>
        <span class="n">eDir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">zDir</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>

        <span class="c1">#one would think that fusing faces into a compound and then extruding would work,</span>
        <span class="c1">#but it doesnt-- the resulting compound appears to look right, ( right number of faces, etc)</span>
        <span class="c1">#but then cutting it from the main solid fails with BRep_NotDone.</span>
        <span class="c1">#the work around is to extrude each and then join the resulting solids, which seems to work</span>

        <span class="c1">#underlying cad kernel can only handle simple bosses-- we&#39;ll aggregate them if there</span>
        <span class="c1"># are multiple sets</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">ws</span> <span class="ow">in</span> <span class="n">wireSets</span><span class="p">:</span>
            <span class="n">thisObj</span> <span class="o">=</span> <span class="n">Solid</span><span class="o">.</span><span class="n">extrudeLinearWithRotation</span><span class="p">(</span><span class="n">ws</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ws</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span>
                                                      <span class="n">eDir</span><span class="p">,</span> <span class="n">angleDegrees</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">r</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">thisObj</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">fuse</span><span class="p">(</span><span class="n">thisObj</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">combine</span><span class="p">:</span>
            <span class="n">newS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combineWithBase</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">r</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">clean</span><span class="p">:</span> <span class="n">newS</span> <span class="o">=</span> <span class="n">newS</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">newS</span></div>

<div class="viewcode-block" id="Workplane.extrude"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.extrude">[docs]</a>    <span class="k">def</span> <span class="nf">extrude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">both</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use all un-extruded wires in the parent chain to create a prismatic solid.</span>

<span class="sd">        :param distance: the distance to extrude, normal to the workplane plane</span>
<span class="sd">        :type distance: float, negative means opposite the normal direction</span>
<span class="sd">        :param boolean combine: True to combine the resulting solid with parent solids if found.</span>
<span class="sd">        :param boolean clean: call :py:meth:`clean` afterwards to have a clean shape</span>
<span class="sd">        :param boolean both: extrude in both directions symmetrically</span>
<span class="sd">        :return: a CQ object with the resulting solid selected.</span>

<span class="sd">        extrude always *adds* material to a part.</span>

<span class="sd">        The returned object is always a CQ object, and depends on wither combine is True, and</span>
<span class="sd">        whether a context solid is already defined:</span>

<span class="sd">        *  if combine is False, the new value is pushed onto the stack.</span>
<span class="sd">        *  if combine is true, the value is combined with the context solid if it exists,</span>
<span class="sd">           and the resulting solid becomes the new context solid.</span>

<span class="sd">        FutureEnhancement:</span>
<span class="sd">            Support for non-prismatic extrusion ( IE, sweeping along a profile, not just</span>
<span class="sd">            perpendicular to the plane extrude to surface. this is quite tricky since the surface</span>
<span class="sd">            selected may not be planar</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extrude</span><span class="p">(</span><span class="n">distance</span><span class="p">,</span><span class="n">both</span><span class="o">=</span><span class="n">both</span><span class="p">)</span>  <span class="c1"># returns a Solid (or a compound if there were multiple)</span>

        <span class="k">if</span> <span class="n">combine</span><span class="p">:</span>
            <span class="n">newS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combineWithBase</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">r</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">clean</span><span class="p">:</span> <span class="n">newS</span> <span class="o">=</span> <span class="n">newS</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">newS</span></div>

<div class="viewcode-block" id="Workplane.revolve"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.revolve">[docs]</a>    <span class="k">def</span> <span class="nf">revolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angleDegrees</span><span class="o">=</span><span class="mf">360.0</span><span class="p">,</span> <span class="n">axisStart</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">axisEnd</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use all un-revolved wires in the parent chain to create a solid.</span>

<span class="sd">        :param angleDegrees: the angle to revolve through.</span>
<span class="sd">        :type angleDegrees: float, anything less than 360 degrees will leave the shape open</span>
<span class="sd">        :param axisStart: the start point of the axis of rotation</span>
<span class="sd">        :type axisStart: tuple, a two tuple</span>
<span class="sd">        :param axisEnd: the end point of the axis of rotation</span>
<span class="sd">        :type axisEnd: tuple, a two tuple</span>
<span class="sd">        :param combine: True to combine the resulting solid with parent solids if found.</span>
<span class="sd">        :type combine: boolean, combine with parent solid</span>
<span class="sd">        :param boolean clean: call :py:meth:`clean` afterwards to have a clean shape</span>
<span class="sd">        :return: a CQ object with the resulting solid selected.</span>

<span class="sd">        The returned object is always a CQ object, and depends on wither combine is True, and</span>
<span class="sd">        whether a context solid is already defined:</span>

<span class="sd">        *  if combine is False, the new value is pushed onto the stack.</span>
<span class="sd">        *  if combine is true, the value is combined with the context solid if it exists,</span>
<span class="sd">           and the resulting solid becomes the new context solid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#Make sure we account for users specifying angles larger than 360 degrees</span>
        <span class="n">angleDegrees</span> <span class="o">%=</span> <span class="mf">360.0</span>

        <span class="c1">#Compensate for FreeCAD not assuming that a 0 degree revolve means a 360 degree revolve</span>
        <span class="n">angleDegrees</span> <span class="o">=</span> <span class="mf">360.0</span> <span class="k">if</span> <span class="n">angleDegrees</span> <span class="o">==</span> <span class="mi">0</span> <span class="k">else</span> <span class="n">angleDegrees</span>

        <span class="c1"># The default start point of the vector defining the axis of rotation will be the origin</span>
        <span class="c1"># of the workplane</span>
        <span class="k">if</span> <span class="n">axisStart</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">axisStart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">toWorldCoords</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">toTuple</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axisStart</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">toWorldCoords</span><span class="p">(</span><span class="n">axisStart</span><span class="p">)</span><span class="o">.</span><span class="n">toTuple</span><span class="p">()</span>

        <span class="c1"># The default end point of the vector defining the axis of rotation should be along the</span>
        <span class="c1"># normal from the plane</span>
        <span class="k">if</span> <span class="n">axisEnd</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="c1"># Make sure we match the user&#39;s assumed axis of rotation if they specified an start</span>
            <span class="c1"># but not an end</span>
            <span class="k">if</span> <span class="n">axisStart</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">axisEnd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">toWorldCoords</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="n">axisStart</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">toTuple</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">axisEnd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">toWorldCoords</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">toTuple</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axisEnd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">toWorldCoords</span><span class="p">(</span><span class="n">axisEnd</span><span class="p">)</span><span class="o">.</span><span class="n">toTuple</span><span class="p">()</span>

        <span class="c1"># returns a Solid (or a compound if there were multiple)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_revolve</span><span class="p">(</span><span class="n">angleDegrees</span><span class="p">,</span> <span class="n">axisStart</span><span class="p">,</span> <span class="n">axisEnd</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">combine</span><span class="p">:</span>
            <span class="n">newS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combineWithBase</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">r</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">clean</span><span class="p">:</span> <span class="n">newS</span> <span class="o">=</span> <span class="n">newS</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">newS</span></div>

<div class="viewcode-block" id="Workplane.sweep"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.sweep">[docs]</a>    <span class="k">def</span> <span class="nf">sweep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">sweepAlongWires</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">makeSolid</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">isFrenet</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use all un-extruded wires in the parent chain to create a swept solid.</span>

<span class="sd">        :param path: A wire along which the pending wires will be swept</span>
<span class="sd">        :param boolean sweepAlongWires:</span>
<span class="sd">            False to create mutliple swept from wires on the chain along path</span>
<span class="sd">            True to create only one solid swept along path with shape following the list of wires on the chain</span>
<span class="sd">        :param boolean combine: True to combine the resulting solid with parent solids if found.</span>
<span class="sd">        :param boolean clean: call :py:meth:`clean` afterwards to have a clean shape</span>
<span class="sd">        :return: a CQ object with the resulting solid selected.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sweep</span><span class="p">(</span><span class="n">path</span><span class="o">.</span><span class="n">wire</span><span class="p">(),</span> <span class="n">sweepAlongWires</span><span class="p">,</span> <span class="n">makeSolid</span><span class="p">,</span> <span class="n">isFrenet</span><span class="p">)</span>  <span class="c1"># returns a Solid (or a compound if there were multiple)</span>
        <span class="k">if</span> <span class="n">combine</span><span class="p">:</span>
            <span class="n">newS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_combineWithBase</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">newS</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">r</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">clean</span><span class="p">:</span> <span class="n">newS</span> <span class="o">=</span> <span class="n">newS</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">newS</span></div>

    <span class="k">def</span> <span class="nf">_combineWithBase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combines the provided object with the base solid, if one can be found.</span>
<span class="sd">        :param obj:</span>
<span class="sd">        :return: a new object that represents the result of combining the base object with obj,</span>
<span class="sd">           or obj if one could not be found</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">baseSolid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findSolid</span><span class="p">(</span><span class="n">searchParents</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">obj</span>
        <span class="k">if</span> <span class="n">baseSolid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">baseSolid</span><span class="o">.</span><span class="n">fuse</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
            <span class="n">baseSolid</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">wrapped</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">r</span><span class="p">])</span>

<div class="viewcode-block" id="Workplane.combine"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.combine">[docs]</a>    <span class="k">def</span> <span class="nf">combine</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Attempts to combine all of the items on the stack into a single item.</span>
<span class="sd">        WARNING: all of the items must be of the same type!</span>

<span class="sd">        :param boolean clean: call :py:meth:`clean` afterwards to have a clean shape</span>
<span class="sd">        :raises: ValueError if there are no items on the stack, or if they cannot be combined</span>
<span class="sd">        :return: a CQ object with the resulting object selected</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">items</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">items</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">ss</span> <span class="ow">in</span> <span class="n">items</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">fuse</span><span class="p">(</span><span class="n">ss</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">clean</span><span class="p">:</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">s</span><span class="p">])</span></div>

<div class="viewcode-block" id="Workplane.union"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.union">[docs]</a>    <span class="k">def</span> <span class="nf">union</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">toUnion</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unions all of the items on the stack of toUnion with the current solid.</span>
<span class="sd">        If there is no current solid, the items in toUnion are unioned together.</span>
<span class="sd">        if combine=True, the result and the original are updated to point to the new object</span>
<span class="sd">        if combine=False, the result will be on the stack, but the original is unmodified</span>

<span class="sd">        :param toUnion:</span>
<span class="sd">        :type toUnion: a solid object, or a CQ object having a solid,</span>
<span class="sd">        :param boolean clean: call :py:meth:`clean` afterwards to have a clean shape</span>
<span class="sd">        :raises: ValueError if there is no solid to add to in the chain</span>
<span class="sd">        :return: a CQ object with the resulting object selected</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#first collect all of the items together</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toUnion</span><span class="p">,</span> <span class="n">CQ</span><span class="p">):</span>
            <span class="n">solids</span> <span class="o">=</span> <span class="n">toUnion</span><span class="o">.</span><span class="n">solids</span><span class="p">()</span><span class="o">.</span><span class="n">vals</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">solids</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;CQ object  must have at least one solid on the stack to union!&quot;</span><span class="p">)</span>
            <span class="n">newS</span> <span class="o">=</span> <span class="n">solids</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">solids</span><span class="p">:</span>
                <span class="n">newS</span> <span class="o">=</span> <span class="n">newS</span><span class="o">.</span><span class="n">fuse</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">toUnion</span><span class="p">)</span> <span class="o">==</span> <span class="n">Solid</span><span class="p">:</span>
            <span class="n">newS</span> <span class="o">=</span> <span class="n">toUnion</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot union type &#39;{}&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">toUnion</span><span class="p">)))</span>

        <span class="c1">#now combine with existing solid, if there is one</span>
        <span class="c1"># look for parents to cut from</span>
        <span class="n">solidRef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findSolid</span><span class="p">(</span><span class="n">searchStack</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">searchParents</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">combine</span> <span class="ow">and</span> <span class="n">solidRef</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">solidRef</span><span class="o">.</span><span class="n">fuse</span><span class="p">(</span><span class="n">newS</span><span class="p">)</span>
            <span class="n">solidRef</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">newS</span><span class="o">.</span><span class="n">wrapped</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">newS</span>

        <span class="k">if</span> <span class="n">clean</span><span class="p">:</span> <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">r</span><span class="p">])</span></div>

<div class="viewcode-block" id="Workplane.cut"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.cut">[docs]</a>    <span class="k">def</span> <span class="nf">cut</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">toCut</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cuts the provided solid from the current solid, IE, perform a solid subtraction</span>

<span class="sd">        if combine=True, the result and the original are updated to point to the new object</span>
<span class="sd">        if combine=False, the result will be on the stack, but the original is unmodified</span>

<span class="sd">        :param toCut: object to cut</span>
<span class="sd">        :type toCut: a solid object, or a CQ object having a solid,</span>
<span class="sd">        :param boolean clean: call :py:meth:`clean` afterwards to have a clean shape</span>
<span class="sd">        :raises: ValueError if there is no solid to subtract from in the chain</span>
<span class="sd">        :return: a CQ object with the resulting object selected</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># look for parents to cut from</span>
        <span class="n">solidRef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findSolid</span><span class="p">(</span><span class="n">searchStack</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">searchParents</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">solidRef</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot find solid to cut from&quot;</span><span class="p">)</span>
        <span class="n">solidToCut</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">toCut</span><span class="p">)</span> <span class="o">==</span> <span class="n">CQ</span> <span class="ow">or</span> <span class="nb">type</span><span class="p">(</span><span class="n">toCut</span><span class="p">)</span> <span class="o">==</span> <span class="n">Workplane</span><span class="p">:</span>
            <span class="n">solidToCut</span> <span class="o">=</span> <span class="n">toCut</span><span class="o">.</span><span class="n">val</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">type</span><span class="p">(</span><span class="n">toCut</span><span class="p">)</span> <span class="o">==</span> <span class="n">Solid</span><span class="p">:</span>
            <span class="n">solidToCut</span> <span class="o">=</span> <span class="n">toCut</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot cut type &#39;{}&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">toCut</span><span class="p">)))</span>

        <span class="n">newS</span> <span class="o">=</span> <span class="n">solidRef</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">solidToCut</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">clean</span><span class="p">:</span> <span class="n">newS</span> <span class="o">=</span> <span class="n">newS</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">combine</span><span class="p">:</span>
            <span class="n">solidRef</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">newS</span><span class="o">.</span><span class="n">wrapped</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">newS</span><span class="p">])</span></div>

<div class="viewcode-block" id="Workplane.intersect"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.intersect">[docs]</a>    <span class="k">def</span> <span class="nf">intersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">toIntersect</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Intersects the provided solid from the current solid.</span>

<span class="sd">        if combine=True, the result and the original are updated to point to the new object</span>
<span class="sd">        if combine=False, the result will be on the stack, but the original is unmodified</span>

<span class="sd">        :param toIntersect: object to intersect</span>
<span class="sd">        :type toIntersect: a solid object, or a CQ object having a solid,</span>
<span class="sd">        :param boolean clean: call :py:meth:`clean` afterwards to have a clean shape</span>
<span class="sd">        :raises: ValueError if there is no solid to intersect with in the chain</span>
<span class="sd">        :return: a CQ object with the resulting object selected</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># look for parents to intersect with</span>
        <span class="n">solidRef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findSolid</span><span class="p">(</span><span class="n">searchStack</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">searchParents</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">solidRef</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot find solid to intersect with&quot;</span><span class="p">)</span>
        <span class="n">solidToIntersect</span> <span class="o">=</span> <span class="bp">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toIntersect</span><span class="p">,</span> <span class="n">CQ</span><span class="p">):</span>
            <span class="n">solidToIntersect</span> <span class="o">=</span> <span class="n">toIntersect</span><span class="o">.</span><span class="n">val</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">toIntersect</span><span class="p">,</span> <span class="n">Solid</span><span class="p">):</span>
            <span class="n">solidToIntersect</span> <span class="o">=</span> <span class="n">toIntersect</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot intersect type &#39;{}&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">toIntersect</span><span class="p">)))</span>

        <span class="n">newS</span> <span class="o">=</span> <span class="n">solidRef</span><span class="o">.</span><span class="n">intersect</span><span class="p">(</span><span class="n">solidToIntersect</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">clean</span><span class="p">:</span> <span class="n">newS</span> <span class="o">=</span> <span class="n">newS</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">combine</span><span class="p">:</span>
            <span class="n">solidRef</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">newS</span><span class="o">.</span><span class="n">wrapped</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">newS</span><span class="p">])</span></div>


<div class="viewcode-block" id="Workplane.cutBlind"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.cutBlind">[docs]</a>    <span class="k">def</span> <span class="nf">cutBlind</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distanceToCut</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use all un-extruded wires in the parent chain to create a prismatic cut from existing solid.</span>

<span class="sd">        Similar to extrude, except that a solid in the parent chain is required to remove material</span>
<span class="sd">        from. cutBlind always removes material from a part.</span>

<span class="sd">        :param distanceToCut: distance to extrude before cutting</span>
<span class="sd">        :type distanceToCut: float, &gt;0 means in the positive direction of the workplane normal,</span>
<span class="sd">            &lt;0 means in the negative direction</span>
<span class="sd">        :param boolean clean: call :py:meth:`clean` afterwards to have a clean shape</span>
<span class="sd">        :raises: ValueError if there is no solid to subtract from in the chain</span>
<span class="sd">        :return: a CQ object with the resulting object selected</span>

<span class="sd">        see :py:meth:`cutThruAll` to cut material from the entire part</span>

<span class="sd">        Future Enhancements:</span>
<span class="sd">            Cut Up to Surface</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#first, make the object</span>
        <span class="n">toCut</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_extrude</span><span class="p">(</span><span class="n">distanceToCut</span><span class="p">)</span>

        <span class="c1">#now find a solid in the chain</span>

        <span class="n">solidRef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findSolid</span><span class="p">()</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">solidRef</span><span class="o">.</span><span class="n">cut</span><span class="p">(</span><span class="n">toCut</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">clean</span><span class="p">:</span> <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span>

        <span class="n">solidRef</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">wrapped</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">s</span><span class="p">])</span></div>

<div class="viewcode-block" id="Workplane.cutThruAll"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.cutThruAll">[docs]</a>    <span class="k">def</span> <span class="nf">cutThruAll</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">positive</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Use all un-extruded wires in the parent chain to create a prismatic cut from existing solid.</span>

<span class="sd">        Similar to extrude, except that a solid in the parent chain is required to remove material</span>
<span class="sd">        from. cutThruAll always removes material from a part.</span>

<span class="sd">        :param boolean positive: True to cut in the positive direction, false to cut in the</span>
<span class="sd">            negative direction</span>
<span class="sd">        :param boolean clean: call :py:meth:`clean` afterwards to have a clean shape</span>
<span class="sd">        :raises: ValueError if there is no solid to subtract from in the chain</span>
<span class="sd">        :return: a CQ object with the resulting object selected</span>

<span class="sd">        see :py:meth:`cutBlind` to cut material to a limited depth</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">maxDim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">largestDimension</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">positive</span><span class="p">:</span>
            <span class="n">maxDim</span> <span class="o">*=</span> <span class="p">(</span><span class="o">-</span><span class="mf">1.0</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cutBlind</span><span class="p">(</span><span class="n">maxDim</span><span class="p">,</span> <span class="n">clean</span><span class="p">)</span></div>

<div class="viewcode-block" id="Workplane.loft"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.loft">[docs]</a>    <span class="k">def</span> <span class="nf">loft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filled</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">ruled</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">combine</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a lofted solid, through the set of wires.</span>
<span class="sd">        :return: a CQ object containing the created loft</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">wiresToLoft</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">pendingWires</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">pendingWires</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">Solid</span><span class="o">.</span><span class="n">makeLoft</span><span class="p">(</span><span class="n">wiresToLoft</span><span class="p">,</span> <span class="n">ruled</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">combine</span><span class="p">:</span>
            <span class="n">parentSolid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">findSolid</span><span class="p">(</span><span class="n">searchStack</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">searchParents</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">parentSolid</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">r</span> <span class="o">=</span> <span class="n">parentSolid</span><span class="o">.</span><span class="n">fuse</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="n">parentSolid</span><span class="o">.</span><span class="n">wrapped</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">wrapped</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">([</span><span class="n">r</span><span class="p">])</span></div>

    <span class="k">def</span> <span class="nf">_extrude</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">both</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a prismatic solid from the existing set of pending wires.</span>

<span class="sd">        :param distance: distance to extrude</span>
<span class="sd">        :param boolean both: extrude in both directions symmetrically</span>
<span class="sd">        :return: a FreeCAD solid, suitable for boolean operations.</span>

<span class="sd">        This method is a utility method, primarily for plugin and internal use.</span>
<span class="sd">        It is the basis for cutBlind,extrude,cutThruAll, and all similar methods.</span>

<span class="sd">        Future Enhancements:</span>
<span class="sd">            extrude along a profile (sweep)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1">#group wires together into faces based on which ones are inside the others</span>
        <span class="c1">#result is a list of lists</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">wireSets</span> <span class="o">=</span> <span class="n">sortWiresByBuildOrder</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">pendingWires</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span> <span class="p">[])</span>
        <span class="c1">#print &quot;sorted wires in %d sec&quot; % ( time.time() - s )</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">pendingWires</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># now all of the wires have been used to create an extrusion</span>

        <span class="c1">#compute extrusion vector and extrude</span>
        <span class="n">eDir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="o">.</span><span class="n">zDir</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">distance</span><span class="p">)</span>


        <span class="c1">#one would think that fusing faces into a compound and then extruding would work,</span>
        <span class="c1">#but it doesnt-- the resulting compound appears to look right, ( right number of faces, etc)</span>
        <span class="c1">#but then cutting it from the main solid fails with BRep_NotDone.</span>
        <span class="c1">#the work around is to extrude each and then join the resulting solids, which seems to work</span>

        <span class="c1"># underlying cad kernel can only handle simple bosses-- we&#39;ll aggregate them if there are</span>
        <span class="c1"># multiple sets</span>

        <span class="c1"># IMPORTANT NOTE: OCC is slow slow slow in boolean operations.  So you do NOT want to fuse</span>
        <span class="c1"># each item to another and save the result-- instead, you want to combine all of the new</span>
        <span class="c1"># items into a compound, and fuse them together!!!</span>
        <span class="c1"># r = None</span>
        <span class="c1"># for ws in wireSets:</span>
        <span class="c1">#     thisObj = Solid.extrudeLinear(ws[0], ws[1:], eDir)</span>
        <span class="c1">#     if r is None:</span>
        <span class="c1">#         r = thisObj</span>
        <span class="c1">#     else:</span>
        <span class="c1">#         s = time.time()</span>
        <span class="c1">#         r = r.fuse(thisObj)</span>
        <span class="c1">#         print &quot;Fused in %0.3f sec&quot; % ( time.time() - s )</span>
        <span class="c1"># return r</span>

        <span class="n">toFuse</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ws</span> <span class="ow">in</span> <span class="n">wireSets</span><span class="p">:</span>
            <span class="n">thisObj</span> <span class="o">=</span> <span class="n">Solid</span><span class="o">.</span><span class="n">extrudeLinear</span><span class="p">(</span><span class="n">ws</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ws</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">eDir</span><span class="p">)</span>
            <span class="n">toFuse</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thisObj</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">both</span><span class="p">:</span>
                <span class="n">thisObj</span> <span class="o">=</span> <span class="n">Solid</span><span class="o">.</span><span class="n">extrudeLinear</span><span class="p">(</span><span class="n">ws</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ws</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">eDir</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="o">-</span><span class="mf">1.</span><span class="p">))</span>
                <span class="n">toFuse</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thisObj</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Compound</span><span class="o">.</span><span class="n">makeCompound</span><span class="p">(</span><span class="n">toFuse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_revolve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angleDegrees</span><span class="p">,</span> <span class="n">axisStart</span><span class="p">,</span> <span class="n">axisEnd</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make a solid from the existing set of pending wires.</span>

<span class="sd">        :param angleDegrees: the angle to revolve through.</span>
<span class="sd">        :type angleDegrees: float, anything less than 360 degrees will leave the shape open</span>
<span class="sd">        :param axisStart: the start point of the axis of rotation</span>
<span class="sd">        :type axisStart: tuple, a two tuple</span>
<span class="sd">        :param axisEnd: the end point of the axis of rotation</span>
<span class="sd">        :type axisEnd: tuple, a two tuple</span>
<span class="sd">        :return: a FreeCAD solid, suitable for boolean operations.</span>

<span class="sd">        This method is a utility method, primarily for plugin and internal use.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#We have to gather the wires to be revolved</span>
        <span class="n">wireSets</span> <span class="o">=</span> <span class="n">sortWiresByBuildOrder</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">pendingWires</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span> <span class="p">[])</span>

        <span class="c1">#Mark that all of the wires have been used to create a revolution</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">pendingWires</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1">#Revolve the wires, make a compound out of them and then fuse them</span>
        <span class="n">toFuse</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ws</span> <span class="ow">in</span> <span class="n">wireSets</span><span class="p">:</span>
            <span class="n">thisObj</span> <span class="o">=</span> <span class="n">Solid</span><span class="o">.</span><span class="n">revolve</span><span class="p">(</span><span class="n">ws</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ws</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">angleDegrees</span><span class="p">,</span> <span class="n">axisStart</span><span class="p">,</span> <span class="n">axisEnd</span><span class="p">)</span>
            <span class="n">toFuse</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thisObj</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Compound</span><span class="o">.</span><span class="n">makeCompound</span><span class="p">(</span><span class="n">toFuse</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_sweep</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">sweepAlongWires</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">makeSolid</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">isFrenet</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Makes a swept solid from an existing set of pending wires.</span>

<span class="sd">        :param path: A wire along which the pending wires will be swept</span>
<span class="sd">        :param boolean sweepAlongWires:</span>
<span class="sd">            False to create mutliple swept from wires on the chain along path</span>
<span class="sd">            True to create only one solid swept along path with shape following the list of wires on the chain</span>
<span class="sd">        :return:a FreeCAD solid, suitable for boolean operations</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># group wires together into faces based on which ones are inside the others</span>
        <span class="c1"># result is a list of lists</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="n">wireSets</span> <span class="o">=</span> <span class="n">sortWiresByBuildOrder</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">pendingWires</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">plane</span><span class="p">,</span> <span class="p">[])</span>
        <span class="c1"># print &quot;sorted wires in %d sec&quot; % ( time.time() - s )</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ctx</span><span class="o">.</span><span class="n">pendingWires</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># now all of the wires have been used to create an extrusion</span>

        <span class="n">toFuse</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sweepAlongWires</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ws</span> <span class="ow">in</span> <span class="n">wireSets</span><span class="p">:</span>
                <span class="n">thisObj</span> <span class="o">=</span> <span class="n">Solid</span><span class="o">.</span><span class="n">sweep</span><span class="p">(</span><span class="n">ws</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ws</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">path</span><span class="o">.</span><span class="n">val</span><span class="p">(),</span> <span class="n">makeSolid</span><span class="p">,</span> <span class="n">isFrenet</span><span class="p">)</span>
                <span class="n">toFuse</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thisObj</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">section</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ws</span> <span class="ow">in</span> <span class="n">wireSets</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ws</span><span class="p">)):</span>
                    <span class="n">section</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ws</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="c1"># implementation</span>
            <span class="n">outW</span> <span class="o">=</span> <span class="n">Wire</span><span class="p">(</span><span class="n">section</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">wrapped</span><span class="p">)</span>
            <span class="n">inW</span> <span class="o">=</span> <span class="n">section</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="n">thisObj</span> <span class="o">=</span> <span class="n">Solid</span><span class="o">.</span><span class="n">sweep</span><span class="p">(</span><span class="n">outW</span><span class="p">,</span> <span class="n">inW</span><span class="p">,</span> <span class="n">path</span><span class="o">.</span><span class="n">val</span><span class="p">(),</span> <span class="n">makeSolid</span><span class="p">,</span> <span class="n">isFrenet</span><span class="p">)</span>
            <span class="n">toFuse</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">thisObj</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Compound</span><span class="o">.</span><span class="n">makeCompound</span><span class="p">(</span><span class="n">toFuse</span><span class="p">)</span>

<div class="viewcode-block" id="Workplane.box"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.box">[docs]</a>    <span class="k">def</span> <span class="nf">box</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">centered</span><span class="o">=</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">),</span> <span class="n">combine</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a 3d box with specified dimensions for each object on the stack.</span>

<span class="sd">        :param length: box size in X direction</span>
<span class="sd">        :type length: float &gt; 0</span>
<span class="sd">        :param width: box size in Y direction</span>
<span class="sd">        :type width: float &gt; 0</span>
<span class="sd">        :param height: box size in Z direction</span>
<span class="sd">        :type height: float &gt; 0</span>
<span class="sd">        :param centered: should the box be centered, or should reference point be at the lower</span>
<span class="sd">            bound of the range?</span>
<span class="sd">        :param combine: should the results be combined with other solids on the stack</span>
<span class="sd">            (and each other)?</span>
<span class="sd">        :type combine: true to combine shapes, false otherwise.</span>
<span class="sd">        :param boolean clean: call :py:meth:`clean` afterwards to have a clean shape</span>

<span class="sd">        Centered is a tuple that describes whether the box should be centered on the x,y, and</span>
<span class="sd">        z axes.  If true, the box is centered on the respective axis relative to the workplane</span>
<span class="sd">        origin, if false, the workplane center will represent the lower bound of the resulting box</span>

<span class="sd">        one box is created for each item on the current stack. If no items are on the stack, one box</span>
<span class="sd">        using the current workplane center is created.</span>

<span class="sd">        If combine is true, the result will be a single object on the stack:</span>
<span class="sd">            if a solid was found in the chain, the result is that solid with all boxes produced</span>
<span class="sd">            fused onto it otherwise, the result is the combination of all the produced boxes</span>

<span class="sd">        if combine is false, the result will be a list of the boxes produced</span>

<span class="sd">        Most often boxes form the basis for a part::</span>

<span class="sd">            #make a single box with lower left corner at origin</span>
<span class="sd">            s = Workplane().box(1,2,3,centered=(False,False,False)</span>

<span class="sd">        But sometimes it is useful to create an array of them:</span>

<span class="sd">            #create 4 small square bumps on a larger base plate:</span>
<span class="sd">            s = Workplane().box(4,4,0.5).faces(&quot;&gt;Z&quot;).workplane()\</span>
<span class="sd">                .rect(3,3,forConstruction=True).vertices().box(0.25,0.25,0.25,combine=True)</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">_makebox</span><span class="p">(</span><span class="n">pnt</span><span class="p">):</span>

            <span class="c1">#(xp,yp,zp) = self.plane.toLocalCoords(pnt)</span>
            <span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">zp</span><span class="p">)</span> <span class="o">=</span> <span class="n">pnt</span><span class="o">.</span><span class="n">toTuple</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">centered</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">xp</span> <span class="o">-=</span> <span class="p">(</span><span class="n">length</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">centered</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">yp</span> <span class="o">-=</span> <span class="p">(</span><span class="n">width</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">centered</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">zp</span> <span class="o">-=</span> <span class="p">(</span><span class="n">height</span> <span class="o">/</span> <span class="mf">2.0</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">Solid</span><span class="o">.</span><span class="n">makeBox</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">Vector</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">zp</span><span class="p">))</span>

        <span class="n">boxes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eachpoint</span><span class="p">(</span><span class="n">_makebox</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

        <span class="c1">#if combination is not desired, just return the created boxes</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">combine</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">boxes</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1">#combine everything</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">boxes</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="n">clean</span><span class="p">)</span></div>

<div class="viewcode-block" id="Workplane.sphere"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.sphere">[docs]</a>    <span class="k">def</span> <span class="nf">sphere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">radius</span><span class="p">,</span> <span class="n">direct</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">angle1</span><span class="o">=-</span><span class="mi">90</span><span class="p">,</span> <span class="n">angle2</span><span class="o">=</span><span class="mi">90</span><span class="p">,</span> <span class="n">angle3</span><span class="o">=</span><span class="mi">360</span><span class="p">,</span>
               <span class="n">centered</span><span class="o">=</span><span class="p">(</span><span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">,</span> <span class="bp">True</span><span class="p">),</span> <span class="n">combine</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a 3D sphere with the specified radius for each point on the stack</span>

<span class="sd">        :param radius: The radius of the sphere</span>
<span class="sd">        :type radius: float &gt; 0</span>
<span class="sd">        :param direct: The direction axis for the creation of the sphere</span>
<span class="sd">        :type direct: A three-tuple</span>
<span class="sd">        :param angle1: The first angle to sweep the sphere arc through</span>
<span class="sd">        :type angle1: float &gt; 0</span>
<span class="sd">        :param angle2: The second angle to sweep the sphere arc through</span>
<span class="sd">        :type angle2: float &gt; 0</span>
<span class="sd">        :param angle3: The third angle to sweep the sphere arc through</span>
<span class="sd">        :type angle3: float &gt; 0</span>
<span class="sd">        :param centered: A three-tuple of booleans that determines whether the sphere is centered</span>
<span class="sd">            on each axis origin</span>
<span class="sd">        :param combine: Whether the results should be combined with other solids on the stack</span>
<span class="sd">            (and each other)</span>
<span class="sd">        :type combine: true to combine shapes, false otherwise</span>
<span class="sd">        :return: A sphere object for each point on the stack</span>

<span class="sd">        Centered is a tuple that describes whether the sphere should be centered on the x,y, and</span>
<span class="sd">        z axes.  If true, the sphere is centered on the respective axis relative to the workplane</span>
<span class="sd">        origin, if false, the workplane center will represent the lower bound of the resulting</span>
<span class="sd">        sphere.</span>

<span class="sd">        One sphere is created for each item on the current stack. If no items are on the stack, one</span>
<span class="sd">        box using the current workplane center is created.</span>

<span class="sd">        If combine is true, the result will be a single object on the stack:</span>
<span class="sd">            If a solid was found in the chain, the result is that solid with all spheres produced</span>
<span class="sd">            fused onto it otherwise, the result is the combination of all the produced boxes</span>

<span class="sd">        If combine is false, the result will be a list of the spheres produced</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Convert the direction tuple to a vector, if needed</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">direct</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">direct</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">(</span><span class="n">direct</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">_makesphere</span><span class="p">(</span><span class="n">pnt</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Inner function that is used to create a sphere for each point/object on the workplane</span>
<span class="sd">            :param pnt: The center point for the sphere</span>
<span class="sd">            :return: A CQ Solid object representing a sphere</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">zp</span><span class="p">)</span> <span class="o">=</span> <span class="n">pnt</span><span class="o">.</span><span class="n">toTuple</span><span class="p">()</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">centered</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">xp</span> <span class="o">+=</span> <span class="n">radius</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">centered</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">yp</span> <span class="o">+=</span> <span class="n">radius</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">centered</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">zp</span> <span class="o">+=</span> <span class="n">radius</span>

            <span class="k">return</span> <span class="n">Solid</span><span class="o">.</span><span class="n">makeSphere</span><span class="p">(</span><span class="n">radius</span><span class="p">,</span> <span class="n">Vector</span><span class="p">(</span><span class="n">xp</span><span class="p">,</span> <span class="n">yp</span><span class="p">,</span> <span class="n">zp</span><span class="p">),</span> <span class="n">direct</span><span class="p">,</span> <span class="n">angle1</span><span class="p">,</span> <span class="n">angle2</span><span class="p">,</span> <span class="n">angle3</span><span class="p">)</span>

        <span class="c1"># We want a sphere for each point on the workplane</span>
        <span class="n">spheres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">eachpoint</span><span class="p">(</span><span class="n">_makesphere</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>

        <span class="c1"># If we don&#39;t need to combine everything, just return the created spheres</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">combine</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">spheres</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">spheres</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="n">clean</span><span class="p">)</span></div>

<div class="viewcode-block" id="Workplane.clean"><a class="viewcode-back" href="../../classreference.html#cadquery.Workplane.clean">[docs]</a>    <span class="k">def</span> <span class="nf">clean</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Cleans the current solid by removing unwanted edges from the</span>
<span class="sd">        faces.</span>

<span class="sd">        Normally you don&#39;t have to call this function. It is</span>
<span class="sd">        automatically called after each related operation. You can</span>
<span class="sd">        disable this behavior with `clean=False` parameter if method</span>
<span class="sd">        has any. In some cases this can improve performance</span>
<span class="sd">        drastically but is generally dis-advised since it may break</span>
<span class="sd">        some operations such as fillet.</span>

<span class="sd">        Note that in some cases where lots of solid operations are</span>
<span class="sd">        chained, `clean()` may actually improve performance since</span>
<span class="sd">        the shape is &#39;simplified&#39; at each step and thus next operation</span>
<span class="sd">        is easier.</span>

<span class="sd">        Also note that, due to limitation of the underlying engine,</span>
<span class="sd">        `clean` may fail to produce a clean output in some cases such as</span>
<span class="sd">        spherical faces.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">cleanObjects</span> <span class="o">=</span> <span class="p">[</span><span class="n">obj</span><span class="o">.</span><span class="n">clean</span><span class="p">()</span> <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">objects</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> object doesn&#39;t support `clean()` method!&quot;</span> <span class="o">%</span> <span class="n">obj</span><span class="o">.</span><span class="n">ShapeType</span><span class="p">())</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">newObject</span><span class="p">(</span><span class="n">cleanObjects</span><span class="p">)</span></div></div>
</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright Parametric Products Intellectual Holdings LLC, All Rights Reserved.

    </p>
  </div> 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../',
            VERSION:'1.2.0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>